<h1>merged.bib</h1><pre>
@COMMENT{{{This file has been generated by bib2bib 1.75}}
</pre>

<pre>
@COMMENT{{{Command line: /usr/bin/bib2bib -oc plclub.keys -ob merged.bib -c bcp:"yes"|plclub:"yes" bcp.bib geoffw.bib jnf.bib weirich.bib zdancewic.bib}}
</pre>

<pre>
@COMMENT{{{{This file has been generated by bib2bib 1.75}}
</pre>

<pre>
@COMMENT{{{{Command line: /usr/bin/bib2bib -ob bcp.bib-tmp -c 'not($key = "poplmark") and not($key = "AITR-474")' bcp.bib}}
</pre>

<pre>
@PREAMBLE{{\newcommand{\SortNoop}[1]{}}}
</pre>

<p><a name="Pierce:gridapple"></a><pre>
@MISC{Pierce:gridapple,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {{\sc Gridapple}: an implementation of the {\sc ESRI} {\sc
                  Grid} system for the {Apple-II}},
  YEAR = {1981},
  NOTE = {Marketed by Environmental Systems Research Institute,
                  Redlands, CA},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce82"></a><pre>
@INPROCEEDINGS{Pierce82,
  AUTHOR = {B. C. Pierce},
  TITLE = {A Microcomputer-Based Geographic Information System},
  BOOKTITLE = {Proceedings of the Seventh West Coast Computer Faire},
  MONTH = MAR,
  YEAR = 1982,
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Larrabee&82"></a><pre>
@MISC{Larrabee&82,
  AUTHOR = {T. Larrabee and K. McCall and C. Mitchell and B. C.
                  Pierce},
  TITLE = {Gambit: {A} Video Game Programming Language},
  HOWPUBLISHED = {Project report for Stanford CS-242 (Programming Language
                  Design)},
  MONTH = {December},
  YEAR = 1982,
  NOTE = {See also: Larrabee, T. and Mitchell, C. ``Gambit: A
                  Prototyping Approach to Video Game Design.'' IEEE Software,
                  Vol. 1 No. 4, Oct. 1984.},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce84"></a><pre>
@INPROCEEDINGS{Pierce84,
  AUTHOR = {B. C. Pierce},
  TITLE = {Gridapple: {A} Microcomputer-Based Geographic Information
                  System},
  BOOKTITLE = {Harvard Computer Graphics Week},
  MONTH = JUL,
  YEAR = 1982,
  NOTE = {Reprinted in Marble, D., et al, {\em Basic Readings in
                  Geographic Information Systems.} Williamsville, NY: SPAD
                  Systems, Ltd., 1984},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce:arcinfo"></a><pre>
@MISC{Pierce:arcinfo,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {{\sc Arc-Info} plotting and display subsystem},
  YEAR = {1982},
  NOTE = {Marketed by Environmental Systems Research Institute,
                  Redlands, CA, USA},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce:artemis"></a><pre>
@MISC{Pierce:artemis,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {{\sc Artemis}: a graphics editor for circuit diagrams},
  YEAR = {1986},
  NOTE = {Used internally at DEC Western Research Lab for the design
                  of the {\sc Titan} processor and power/packaging},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Habermann&88"></a><pre>
@TECHREPORT{Habermann&88,
  AUTHOR = {A. N. Habermann and Charles Krueger and Benjamin Pierce
                  and Barbara Staudt and John Wenn},
  TITLE = {Programming with Views},
  INSTITUTION = {Carnegie Mellon University, Computer Science Department},
  NUMBER = {CMU-CS-87-177},
  MONTH = JAN,
  YEAR = {1988},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PIERCE89B"></a><pre>
@TECHREPORT{PIERCE89B,
  KEY = {Pierce89b},
  AUTHOR = {Benjamin Pierce},
  TITLE = {A Decision Procedure for the Subtype Relation on
                  Intersection Types with Bounded Variables},
  INSTITUTION = {School of Computer Science, Carnegie Mellon University},
  TYPE = {Technical Report},
  NUMBER = {CMU-CS-89-169},
  MONTH = SEP,
  YEAR = {1989},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PIERCE89C"></a><pre>
@UNPUBLISHED{PIERCE89C,
  KEY = {PIERCE89C},
  AUTHOR = {Benjamin Pierce},
  TITLE = {Bounded Quantification and Intersection Types},
  MONTH = SEP,
  YEAR = {1989},
  NOTE = {Thesis proposal (unpublished)},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PIERCE89"></a><pre>
@TECHREPORT{PIERCE89,
  KEY = {Pierce89},
  AUTHOR = {Benjamin Pierce and Scott Dietzen and Spiro Michaylov},
  TITLE = {Programming in Higher-order Typed Lambda-Calculi},
  INSTITUTION = {Carnegie Mellon University},
  TYPE = {Technical Report},
  NUMBER = {CMU-CS-89-111},
  MONTH = MAR,
  YEAR = {1989},
  PLCLUB = {Yes},
  BCP = {Yes},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/leap.pdf">http://www.cis.upenn.edu/~bcpierce/papers/leap.pdf</a>},
  ERRATA = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/leap.errata">http://www.cis.upenn.edu/~bcpierce/papers/leap.errata</a>},
  KEYS = {typessurveys}
}
</pre>
</p>
<p><a name="HarperPierce90"></a><pre>
@TECHREPORT{HarperPierce90,
  AUTHOR = {Robert W. Harper and Benjamin C. Pierce},
  TITLE = {Extensible Records Without Subsumption},
  INSTITUTION = {School of Computer Science, Carnegie Mellon University},
  YEAR = {1990},
  MONTH = FEB,
  TYPE = {Technical Report},
  NUMBER = {CMU-CS-90-102},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce90b"></a><pre>
@UNPUBLISHED{Pierce90b,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Preliminary Investigation of a Calculus with Intersection
                  and Union Types},
  YEAR = 1990,
  MONTH = JUN,
  NOTE = {Unpublished manuscript},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="HarperPierce91"></a><pre>
@INPROCEEDINGS{HarperPierce91,
  AUTHOR = {Robert Harper and Benjamin Pierce},
  TITLE = {A Record Calculus Based on Symmetric Concatenation},
  BOOKTITLE = {{ACM} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Orlando, Florida},
  YEAR = 1991,
  PAGES = {131--142},
  MONTH = JAN,
  NOTE = {Extended version available as Carnegie Mellon Technical
                  Report CMU-CS-90-157},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PIERCE91"></a><pre>
@BOOK{PIERCE91,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Basic Category Theory for Computer Scientists},
  YEAR = {1991},
  PUBLISHER = {MIT Press},
  FULLISBN = {0-262-66071-7},
  ORDERINGINFO = {MIT PRESS 55 Hayward ST. Cambridge Mass 02142 USA
                  800-356-0343},
  EUROPEINFO = {14 Bloomsbury Square London WC1A 2LP U.K. Facsimile:
                  071-404-0601},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {books}
}
</pre>
</p>
<p><a name="ABADI91"></a><pre>
@ARTICLE{ABADI91,
  AUTHOR = {Mart\'{\i}n Abadi and Luca Cardelli and Benjamin Pierce
                  and Gordon Plotkin},
  TITLE = {Dynamic Typing in a Statically Typed Language},
  JOURNAL = {ACM Transactions on Programming Languages and Systems},
  PUBLISHER = {ACM},
  YEAR = 1991,
  VOLUME = 13,
  NUMBER = 2,
  MONTH = APR,
  PAGES = {237--268},
  NOTE = {Summary in \bgroup\em {ACM} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Austin, Texas\egroup, 1989},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="ABADI91B"></a><pre>
@ARTICLE{ABADI91B,
  AUTHOR = {Mart\'{\i}n Abadi and Benjamin Pierce and Gordon Plotkin},
  TITLE = {Faithful Ideal Models for Recursive Polymorphic Types},
  JOURNAL = {International Journal of Foundations of Computer Science},
  VOLUME = 2,
  NUMBER = 1,
  MONTH = MAR,
  YEAR = 1991,
  PAGES = {1--21},
  NOTE = {Summary in Fourth Annual Symposium on Logic in Computer
                  Science, June, 1989},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce91b"></a><pre>
@TECHREPORT{Pierce91b,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Programming with Intersection Types, Union Types, and
                  Polymorphism},
  INSTITUTION = {Carnegie Mellon University},
  TYPE = {Technical Report},
  NUMBER = {CMU-CS-91-106},
  MONTH = FEB,
  YEAR = {1991},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceThesis"></a><pre>
@PHDTHESIS{PierceThesis,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Programming with Intersection Types and Bounded
                  Polymorphism},
  SCHOOL = {Carnegie Mellon University},
  MONTH = {December},
  YEAR = {1991},
  NOTE = {Available as School of Computer Science technical report
                  CMU-CS-91-205},
  ASCII = {Benjamin C. Pierce, "Programming with Intersection Types
                  and Bounded Polymorphism." Ph.D. thesis, Carnegie Mellon
                  University, December, 1991. Available as School of Computer
                  Science technical report CMU-CS-91-205.},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce:fmeet"></a><pre>
@MISC{Pierce:fmeet,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {{\sc Fmeet}: a polymorphic $\lambda$-calculus with
                  intersection types},
  YEAR = {1991},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="HofmannPierce92:TR"></a><pre>
@TECHREPORT{HofmannPierce92:TR,
  AUTHOR = {Martin Hofmann and Benjamin Pierce},
  TITLE = {An Abstract View of Objects and Subtyping (Preliminary
                  Report)},
  INSTITUTION = {University of Edinburgh, LFCS},
  TYPE = {Technical Report},
  NUMBER = {ECS-LFCS-92-226},
  YEAR = {1992},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce92d"></a><pre>
@UNPUBLISHED{Pierce92d,
  AUTHOR = {Benjamin C. Pierce and Robert Pollack},
  TITLE = {Higher-Order Subtyping},
  YEAR = {1992},
  MONTH = AUG,
  NOTE = {Unpublished manuscript},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce:delegation"></a><pre>
@UNPUBLISHED{Pierce:delegation,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {A Model of Delegation Based on Existential Types},
  YEAR = {1993},
  MONTH = APR,
  NOTE = {Available electronically},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYWORDS = {oop},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/delegation.ps">http://www.cis.upenn.edu/~bcpierce/papers/delegation.ps</a>}
}
</pre>
</p>
<p><a name="Pierce:Kyoto-talk"></a><pre>
@MISC{Pierce:Kyoto-talk,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {A Typed Higher-Order Programming Language Based on the
                  Pi-Calculus},
  MONTH = JUL,
  YEAR = {1993},
  NOTE = {Invited lecture at {\em Workshop on Type Theory and its
                  Application to Computer Systems}, Kyoto University},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceRemyTurner93"></a><pre>
@INPROCEEDINGS{PierceRemyTurner93,
  AUTHOR = {Benjamin C. Pierce and Didier R\'emy and David N. Turner},
  TITLE = {A Typed Higher-Order Programming Language Based on the
                  Pi-Calculus},
  MONTH = JUL,
  YEAR = {1993},
  BOOKTITLE = {Workshop on Type Theory and its Application to Computer
                  Systems, Kyoto University},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce92g"></a><pre>
@UNPUBLISHED{Pierce92g,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {F-Omega-Sub User's Manual, Version 1.4},
  YEAR = {1993},
  MONTH = FEB,
  NOTE = {Available by FTP as part of the {\tt fomega}
                  implementation},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce:mutable"></a><pre>
@UNPUBLISHED{Pierce:mutable,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Mutable Objects},
  YEAR = {1993},
  MONTH = JUN,
  NOTE = {Draft report; available electronically},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYWORDS = {oop},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/mutable.ps">http://www.cis.upenn.edu/~bcpierce/papers/mutable.ps</a>}
}
</pre>
</p>
<p><a name="PierceTurner92:POPL"></a><pre>
@INPROCEEDINGS{PierceTurner92:POPL,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Object-Oriented Programming Without Recursive Types},
  BOOKTITLE = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Charleston, South Carolina},
  YEAR = {1993},
  MONTH = JAN,
  PAGES = {299--312},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce93c"></a><pre>
@UNPUBLISHED{Pierce93c,
  AUTHOR = {Benjamin Pierce},
  TITLE = {Object-Oriented Programming in Typed Lambda-Calculus:
                  Exercises and Solutions},
  YEAR = {1993},
  MONTH = APR,
  NOTE = {Lecture notes for 1992 Frankische OOrientierungstage,
                  University of Erlangen, Germany (revised version)},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceTurner92b"></a><pre>
@TECHREPORT{PierceTurner92b,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Statically Typed Friendly Functions via Partially Abstract
                  Types},
  INSTITUTION = {University of Edinburgh, LFCS},
  TYPE = {Technical Report},
  NUMBER = {ECS-LFCS-93-256},
  MONTH = APR,
  YEAR = {1993},
  NOTE = {Also available as INRIA-Rocquencourt Rapport de Recherche
                  No. 1899},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYWORDS = {oop},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/friendly.ps">http://www.cis.upenn.edu/~bcpierce/papers/friendly.ps</a>}
}
</pre>
</p>
<p><a name="Pierce:JFLA-talk"></a><pre>
@MISC{Pierce:JFLA-talk,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Typage des Traits Orient\'es-Objets},
  MONTH = FEB,
  YEAR = {1993},
  NOTE = {Invited lecture at {\em Journe\'es Francophones des
                  Langages Applicatifs}, Annecy, France},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceSangiorgi95"></a><pre>
@INPROCEEDINGS{PierceSangiorgi95,
  AUTHOR = {Benjamin C. Pierce and Davide Sangiorgi},
  TITLE = {Typing and Subtyping for Mobile Processes},
  BOOKTITLE = {Logic in Computer Science},
  YEAR = {1993},
  NOTE = {Full version in \bgroup\em Mathematical Structures in
                  Computer Science \egroup, Vol.\ 6, No.\ 5, 1996},
  FULL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/pi.ps">http://www.cis.upenn.edu/~bcpierce/papers/pi.ps</a>},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {pi}
}
</pre>
</p>
<p><a name="Pierce:fomega"></a><pre>
@MISC{Pierce:fomega,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {{\sc F-Omega-Sub}: a polymorphic $\lambda$-calculus with
                  higher-order subtyping and object-oriented extensions},
  YEAR = {1993},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce92a"></a><pre>
@ARTICLE{Pierce92a,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Bounded Quantification is Undecidable},
  JOURNAL = {Information and Computation},
  YEAR = 1994,
  VOLUME = 112,
  NUMBER = 1,
  PAGES = {131--165},
  MONTH = JUL,
  NOTE = {Also in C. A. Gunter and J. C. Mitchell, editors, {\em
                    Theoretical Aspects of Object-Oriented Programming:
                    Types, Semantics, and Language Design}, MIT Press, 1994. Summary in \bgroup \em {ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Albuquerque, New Mexico\egroup},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {subtyping},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fsubpopl.ps">http://www.cis.upenn.edu/~bcpierce/papers/fsubpopl.ps</a>}
}
</pre>
</p>
<p><a name="Pierce:COPC-talk"></a><pre>
@MISC{Pierce:COPC-talk,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Concurrent Objects in a Process Calculus},
  NOTE = {Invited lecture at {\em Theory and Practice of Parallel
                  Programming (TPPP)}, Sendai, Japan},
  YEAR = 1994,
  MONTH = NOV,
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="CastagnaPierce93"></a><pre>
@INPROCEEDINGS{CastagnaPierce93,
  AUTHOR = {Giuseppe Castagna and Benjamin Pierce},
  TITLE = {Decidable Bounded Quantification},
  BOOKTITLE = {Proceedings of the Twenty-First {ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Portland, Oregon},
  PUBLISHER = {ACM},
  YEAR = 1994,
  MONTH = JAN,
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {subtyping},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fsubnew.ps">http://www.cis.upenn.edu/~bcpierce/papers/fsubnew.ps</a>}
}
</pre>
</p>
<p><a name="PierceSteffen95"></a><pre>
@INPROCEEDINGS{PierceSteffen95,
  AUTHOR = {Benjamin C. Pierce and Martin Steffen},
  REALAUTHOR = {Benjamin Pierce and Martin Steffen},
  TITLE = {Higher-Order Subtyping},
  BOOKTITLE = {IFIP Working Conference on Programming Concepts, Methods
                  and Calculi (PROCOMET)},
  YEAR = 1994,
  NOTE = {Full version in \bgroup\em Theoretical Computer
                  Science\egroup, vol.~176, no.~1--2, pp.\  235--282, 1997
                  (corrigendum in TCS vol.~184 (1997), p.~247)},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {subtyping},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fomega.ps">http://www.cis.upenn.edu/~bcpierce/papers/fomega.ps</a>}
}
</pre>
</p>
<p><a name="SteffenPierce93:TR"></a><pre>
@TECHREPORT{SteffenPierce93:TR,
  AUTHOR = {Martin Steffen and Benjamin Pierce},
  TITLE = {Higher-Order Subtyping},
  YEAR = {1994},
  MONTH = JAN,
  INSTITUTION = {LFCS, University of Edinburgh},
  NUMBER = {ECS-LFCS-94-280},
  NOTE = {Also available as {Universit\"at Erlangen-N\"urnberg
                  Interner Bericht IMMD7-01/94}. To appear in Theoretical
                  Computer Science.},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="HofmannPierce94a:TR"></a><pre>
@TECHREPORT{HofmannPierce94a:TR,
  AUTHOR = {Martin Hofmann and Benjamin Pierce},
  TITLE = {Positive Subtyping},
  YEAR = {1994},
  MONTH = SEP,
  INSTITUTION = {LFCS, University of Edinburgh},
  NUMBER = {ECS-LFCS-94-303},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceTurner92"></a><pre>
@ARTICLE{PierceTurner92,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Simple Type-Theoretic Foundations for Object-Oriented
                  Programming},
  NOTE = {Summary in \bgroup\em {ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Charleston, South Carolina\egroup, 1993},
  JOURNAL = {Journal of Functional Programming},
  VOLUME = 4,
  NUMBER = 2,
  MONTH = APR,
  PAGES = {207--247},
  YEAR = {1994},
  PLCLUB = {Yes},
  BCP = {Yes},
  PDF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/oop.pdf">http://www.cis.upenn.edu/~bcpierce/papers/oop.pdf</a>},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/oop.ps">http://www.cis.upenn.edu/~bcpierce/papers/oop.ps</a>},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/oop-popl.ps">http://www.cis.upenn.edu/~bcpierce/papers/oop-popl.ps</a>},
  KEYWORDS = {oop}
}
</pre>
</p>
<p><a name="Pierce94a"></a><pre>
@ARTICLE{Pierce94a,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Woggles from {O}z: {W}riting Interactive Fiction},
  NOTE = {Expanded version available electronically},
  JOURNAL = {Leonardo: Journal of the International Society for the
                  Arts, Sciences, and Technology},
  YEAR = {1994},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="HofmannPierce94"></a><pre>
@ARTICLE{HofmannPierce94,
  AUTHOR = {Martin Hofmann and Benjamin Pierce},
  TITLE = {A Unifying Type-Theoretic Framework for Objects},
  JOURNAL = {Journal of Functional Programming},
  VOLUME = {5},
  NUMBER = {4},
  PAGES = {593--635},
  MONTH = OCT,
  NOTE = {Previous versions appeared in the Symposium on Theoretical
                  Aspects of Computer Science, 1994, (pages 251--262) and,
                  under the title ``An Abstract View of Objects and Subtyping
                  (Preliminary Report),'' as University of Edinburgh, LFCS
                  technical report ECS-LFCS-92-226, 1992},
  YEAR = 1995,
  PLCLUB = {Yes},
  BCP = {Yes},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/abstroop.ps">http://www.cis.upenn.edu/~bcpierce/papers/abstroop.ps</a>},
  KEYWORDS = {oop}
}
</pre>
</p>
<p><a name="PierceTurner94:COPC"></a><pre>
@INPROCEEDINGS{PierceTurner94:COPC,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Concurrent Objects in a Process Calculus},
  BOOKTITLE = {Theory and Practice of Parallel Programming (TPPP),
                  Sendai, Japan (Nov.{} 1994)},
  EDITOR = {Takayasu Ito and Akinori Yonezawa},
  YEAR = {1995},
  MONTH = APR,
  PUBLISHER = {Springer-Verlag},
  SERIES = {Lecture Notes in Computer Science},
  NUMBER = {907},
  PAGES = {187--215},
  SHORT = {<a href="./``Concurrent Objects in a Process Calculus,'' Benjamin C.
                  Pierce and David N. Turner, invited lecture at {\it Theory
                  and Practice of Parallel Programming (TPPP)}, Sendai, Japan
                  (Nov.{} 1994). Springer Lecture Notes in Computer Science
                  907, pp.~187--215">``Concurrent Objects in a Process Calculus,'' Benjamin C.
                  Pierce and David N. Turner, invited lecture at {\it Theory
                  and Practice of Parallel Programming (TPPP)}, Sendai, Japan
                  (Nov.{} 1994). Springer Lecture Notes in Computer Science
                  907, pp.~187--215</a>},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {pi},
  URL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/copc.ps">http://www.cis.upenn.edu/~bcpierce/papers/copc.ps</a>}
}
</pre>
</p>
<p><a name="CastagnaPierce95"></a><pre>
@INPROCEEDINGS{CastagnaPierce95,
  AUTHOR = {Giuseppe Castagna and Benjamin Pierce},
  TITLE = {Corrigendum: Decidable Bounded Quantification},
  BOOKTITLE = {Proceedings of the Twenty-Second {ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Portland, Oregon},
  PUBLISHER = {ACM},
  YEAR = 1995,
  MONTH = JAN,
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {subtyping},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fsubnew-corrigendum.ps">http://www.cis.upenn.edu/~bcpierce/papers/fsubnew-corrigendum.ps</a>}
}
</pre>
</p>
<p><a name="Abadi92"></a><pre>
@ARTICLE{Abadi92,
  AUTHOR = {Mart\'{\i}n Abadi and Luca Cardelli and Benjamin Pierce
                  and Didier R\'{e}my},
  TITLE = {Dynamic Typing in Polymorphic Languages},
  JOURNAL = {Journal of Functional Programming},
  VOLUME = {5},
  NUMBER = {1},
  PAGES = {111--130},
  MONTH = JAN,
  NOTE = {Summary in \bgroup \em ACM SIGPLAN Workshop on ML and its
                  Applications\egroup, June 1992},
  YEAR = 1995,
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce:LinearPiTalk"></a><pre>
@MISC{Pierce:LinearPiTalk,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Linearity and the Pi-Calculus},
  NOTE = {Invited lecture at {\em Advances in Type Systems for
                  Computation}, Cambridge, England},
  YEAR = 1995,
  MONTH = AUG,
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="KobayashiPierceTurner:LinearPiTR"></a><pre>
@MISC{KobayashiPierceTurner:LinearPiTR,
  AUTHOR = {Naoki Kobayashi and Benjamin C. Pierce and David N.
                  Turner},
  TITLE = {Linearity and the Pi-Calculus},
  YEAR = {1995},
  NOTE = {Technical report, Department of Information Science,
                  University of Tokyo and Computer Laboratory, University of
                  Cambridge},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="HofmannPierce94a"></a><pre>
@INPROCEEDINGS{HofmannPierce94a,
  AUTHOR = {Martin Hofmann and Benjamin Pierce},
  TITLE = {Positive Subtyping},
  BOOKTITLE = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), San Francisco, California},
  YEAR = {1995},
  MONTH = JAN,
  PAGES = {186--197},
  NOTE = {Full version in \bgroup\em Information and
                  Computation\egroup, volume 126, number 1, April 1996. Also
                  available as University of Edinburgh technical report
                  ECS-LFCS-94-303, September 1994},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYWORDS = {oop},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/pos.ps">http://www.cis.upenn.edu/~bcpierce/papers/pos.ps</a>}
}
</pre>
</p>
<p><a name="Pierce:LICSSurvey"></a><pre>
@MISC{Pierce:LICSSurvey,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Types and Programming Languages: The Next Generation},
  NOTE = {Invited tutorial at {\em Logic in Computer Science (LICS)}},
  YEAR = 2003,
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {typessurveys},
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tng-lics2003-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/tng-lics2003-slides.pdf</a>}
}
</pre>
</p>
<p><a name="Pierce:ModulesTutorial"></a><pre>
@MISC{Pierce:ModulesTutorial,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Advanced Module Systems: A Guide for the Perplexed},
  NOTE = {Invited tutorial at {\em International Conference on Functional
                  Programming (ICFP)}},
  YEAR = 2000,
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {typessurveys},
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/modules-icfp.ps">http://www.cis.upenn.edu/~bcpierce/papers/modules-icfp.ps</a>}
}
</pre>
</p>
<p><a name="Pierce:HorizonDayTalk"></a><pre>
@MISC{Pierce:HorizonDayTalk,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Using Types to Compare Objects and {ADT}s},
  NOTE = {Invited lecture at {\em Horizon Day}, Indiana University},
  YEAR = 1995,
  MONTH = OCT,
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="BruceCardelliPierce96:old"></a><pre>
@INPROCEEDINGS{BruceCardelliPierce96:old,
  AUTHOR = {Kim B. Bruce and Luca Cardelli and Benjamin C. Pierce},
  TITLE = {Comparing Object Encodings},
  BOOKTITLE = {Invited lecture at Third Workshop on Foundations of Object
                  Oriented Languages (FOOL 3)},
  YEAR = 1996,
  MONTH = JUL,
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="NestmannPierce96"></a><pre>
@INPROCEEDINGS{NestmannPierce96,
  AUTHOR = {Uwe Nestmann and Benjamin C. Pierce},
  TITLE = {Decoding Choice Encodings},
  BOOKTITLE = {Proceedings of CONCUR '96},
  YEAR = 1996,
  MONTH = AUG,
  NOTE = {Full version in \bgroup\em Information and
                  Computation\egroup, 163(1): 1--59 (2000)},
  PLCLUB = {Yes},
  BCP = {Yes},
  FULL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/choice.ps">http://www.cis.upenn.edu/~bcpierce/papers/choice.ps</a>},
  KEYS = {pi}
}
</pre>
</p>
<p><a name="Pierce:EvenSimpler"></a><pre>
@UNPUBLISHED{Pierce:EvenSimpler,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Even simpler type-theoretic foundations for {OOP}},
  MONTH = MAR,
  YEAR = {1996},
  NOTE = {Manuscript (circulated electronically)},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce95a"></a><pre>
@INCOLLECTION{Pierce95a,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Foundational Calculi for Programming Languages},
  BOOKTITLE = {Handbook of Computer Science and Engineering},
  CHAPTER = {139},
  PUBLISHER = {CRC Press},
  YEAR = {1996},
  EDITOR = {Allen B. Tucker},
  PLCLUB = {Yes},
  BCP = {Yes},
  FULL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/crchandbook.ps">http://www.cis.upenn.edu/~bcpierce/papers/crchandbook.ps</a>},
  KEYS = {pi}
}
</pre>
</p>
<p><a name="CompagnoniPierce93"></a><pre>
@ARTICLE{CompagnoniPierce93,
  AUTHOR = {Adriana B. Compagnoni and Benjamin C. Pierce},
  TITLE = {Intersection Types and Multiple Inheritance},
  PAGES = {469--501},
  JOURNAL = {Mathematical Structures in Computer Science},
  MONTH = OCT,
  YEAR = 1996,
  VOLUME = 6,
  NUMBER = 5,
  SOURCE = {<a href="http://theory.lcs.mit.edu/~dmjones/hbp/mscs/mscs.bib">http://theory.lcs.mit.edu/~dmjones/hbp/mscs/mscs.bib</a>},
  NOTE = {Preliminary version available as University of Edinburgh
                  technical report ECS-LFCS-93-275 and Catholic University
                  Nijmegen computer science technical report 93-18, Aug.
                  1993, under the title ``Multiple Inheritance via
                  Intersection Types''},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="KobayashiPierceTurner:LinearPi"></a><pre>
@INPROCEEDINGS{KobayashiPierceTurner:LinearPi,
  AUTHOR = {Naoki Kobayashi and Benjamin C. Pierce and David N.
                  Turner},
  TITLE = {Linearity and the Pi-Calculus},
  YEAR = {1996},
  BOOKTITLE = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), St.~Petersburg Beach, Florida},
  NOTE = {Full version in \bgroup\em ACM Transactions on Programming Languages and Systems\egroup, 21(5), pp. 914--947, September 1999},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="CompagnoniPierce93:old"></a><pre>
@ARTICLE{CompagnoniPierce93:old,
  AUTHOR = {Adriana B. Compagnoni and Benjamin C. Pierce},
  TITLE = {Multiple Inheritance via Intersection Types},
  JOURNAL = {Mathematical Structures in Computer Science},
  YEAR = 1996,
  NOTE = {To appear. Preliminary version available as University of
                  Edinburgh technical report ECS-LFCS-93-275 and Catholic
                  University Nijmegen computer science technical report
                  93-18, Aug. 1993},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="OnBinaryMethods"></a><pre>
@ARTICLE{OnBinaryMethods,
  AUTHOR = {Kim B. Bruce and Luca Cardelli and Giuseppe Castagna and
                  {the Hopkins Objects Group (Jonathan Eifrig, Scott Smith,
                  Valery Trifonov)} and Gary T. Leavens and Benjamin Pierce},
  TITLE = {On Binary Methods},
  JOURNAL = {Theory and Practice of Object Systems},
  VOLUME = 1,
  NUMBER = 3,
  PAGES = {221--242},
  YEAR = 1996,
  CHECKED = {No},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYWORDS = {oop},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/binary.ps">http://www.cis.upenn.edu/~bcpierce/papers/binary.ps</a>}
}
</pre>
</p>
<p><a name="Pierce:FMOODSTalk"></a><pre>
@MISC{Pierce:FMOODSTalk,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Processes, Types, and Observations},
  NOTE = {Invited lecture at {\em Formal Methods on Open,
                  Object-Based Distributed Systems (FMOODS)}, Paris},
  YEAR = 1996,
  MONTH = MAR,
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce96a"></a><pre>
@UNPUBLISHED{Pierce96a,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Types},
  NOTE = {Lecture notes for an undergraduate course at Cambridge
                  University},
  MONTH = FEB,
  YEAR = 1996,
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceSangiorgi96"></a><pre>
@INPROCEEDINGS{PierceSangiorgi96,
  AUTHOR = {Benjamin Pierce and Davide Sangiorgi},
  TITLE = {Behavioral Equivalence in the Polymorphic Pi-Calculus},
  YEAR = 1997,
  BOOKTITLE = {Principles of Programming Languages (POPL)},
  NOTE = {Full version in {\em Journal of the Association for
                  Computing Machinery (JACM)}, 47(3), May 2000},
  PAGES = {531--584},
  FULL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/polybisim.ps">http://www.cis.upenn.edu/~bcpierce/papers/polybisim.ps</a>},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {pi}
}
</pre>
</p>
<p><a name="Pierce:BQB"></a><pre>
@TECHREPORT{Pierce:BQB,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Bounded Quantification with Bottom},
  YEAR = {1997},
  INSTITUTION = {Computer Science Department, Indiana University},
  SERIES = {CSCI},
  NUMBER = {492},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {subtyping},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/bqb.ps">http://www.cis.upenn.edu/~bcpierce/papers/bqb.ps</a>}
}
</pre>
</p>
<p><a name="BruceCardelliPierce96:TACS"></a><pre>
@INPROCEEDINGS{BruceCardelliPierce96:TACS,
  AUTHOR = {Kim B. Bruce and Luca Cardelli and Benjamin C. Pierce},
  TITLE = {Comparing Object Encodings},
  BOOKTITLE = {International Symposium on Theoretical Aspects of Computer Software (TACS)},
  YEAR = 1997,
  MONTH = SEP,
  NOTE = {An earlier version was presented as an invited lecture at
                  the Third International Workshop on Foundations of Object
                  Oriented Languages (FOOL 3), July 1996; full version in \bgroup\em Information and Computation\egroup, 155(1--2):108-133, 1999},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceSteffen95:old"></a><pre>
@ARTICLE{PierceSteffen95:old,
  AUTHOR = {Benjamin Pierce and Martin Steffen},
  TITLE = {Higher-Order Subtyping},
  YEAR = 1997,
  JOURNAL = {Theoretical Computer Science},
  VOLUME = 176,
  NUMBER = {1--2},
  PAGES = {235--282},
  NOTE = {Summary in IFIP Working Conference on Programming
                  Concepts, Methods and Calculi (PROCOMET), June 1994; also
                  University of Edinburgh technical report ECS-LFCS-94-280
                  and {Universit\"at Erlangen-N\"urnberg Interner Bericht
                  IMMD7-01/94}, January 1994.},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce92b"></a><pre>
@ARTICLE{Pierce92b,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Intersection Types and Bounded Polymorphism},
  PAGES = {129--193},
  JOURNAL = {Mathematical Structures in Computer Science},
  MONTH = APR,
  YEAR = 1997,
  VOLUME = 7,
  NUMBER = 2,
  SOURCE = {<a href="http://theory.lcs.mit.edu/~dmjones/hbp/mscs/mscs.bib">http://theory.lcs.mit.edu/~dmjones/hbp/mscs/mscs.bib</a>},
  NOTE = {Summary in {\em Typed Lambda
                  Calculi and Applications}, March 1993, pp. 346--360},
  ASCII = {Benjamin C. Pierce, "Intersection Types and Bounded
                  Polymorphism." Conference on Typed Lambda Calculi and
                  Applications, March, 1993},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce:LFPTW"></a><pre>
@MISC{Pierce:LFPTW,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Languages for Programming the Web},
  MONTH = DEC,
  YEAR = {1997},
  NOTE = {Course materials for a graduate seminar on the theory and
                  practice of mobile agent programming. Available through
                  {\tt http://www.cis.upenn.edu/$sim$bcpierce/courses/629}.},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceTurner:LTI-FSUB"></a><pre>
@TECHREPORT{PierceTurner:LTI-FSUB,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Local Type Argument Synthesis with Bounded Quantification},
  YEAR = {1997},
  INSTITUTION = {Computer Science Department, Indiana University},
  MONTH = JAN,
  SERIES = {CSCI},
  NUMBER = {495},
  PLCLUB = {Yes},
  BCP = {Yes},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lti-fsub.ps">http://www.cis.upenn.edu/~bcpierce/papers/lti-fsub.ps</a>},
  KEYS = {inference}
}
</pre>
</p>
<p><a name="PierceTurner:LTI-TR"></a><pre>
@TECHREPORT{PierceTurner:LTI-TR,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Local Type Inference},
  YEAR = {1997},
  INSTITUTION = {Computer Science Department, Indiana University},
  SERIES = {CSCI},
  NUMBER = {493},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceTurner:PictDefn"></a><pre>
@UNPUBLISHED{PierceTurner:PictDefn,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Pict Language Definition},
  YEAR = {1997},
  NOTE = {Available electronically},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceTurner:PictLib"></a><pre>
@UNPUBLISHED{PierceTurner:PictLib,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Pict Libraries Manual},
  YEAR = {1997},
  NOTE = {Available electronically},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceTurner:PictCompiler"></a><pre>
@MISC{PierceTurner:PictCompiler,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Pict: A Programming Language Based on the Pi-Calculus},
  YEAR = {1997},
  NOTE = {\URL{http://www.cis.upenn.edu/~bcpierce/papers/pict}},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PictDistribution"></a><pre>
@MISC{PictDistribution,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {The {Pict} Programming Language},
  YEAR = {2001},
  HOMEPAGE = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/pict/Html/Pict.html">http://www.cis.upenn.edu/~bcpierce/papers/pict/Html/Pict.html</a>},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {pi},
  NOTE = {This directory contains various papers, including a tutorial and user's manual, as well as complete compiler sources and installation instructions. (Be sure not to miss the artwork department!)}
}
</pre>
</p>
<p><a name="Pierce94b"></a><pre>
@UNPUBLISHED{Pierce94b,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Programming in the Pi-Calculus: {A} Tutorial Introduction
                  to {P}ict},
  YEAR = {1997},
  NOTE = {Available electronically},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce98:ACReview"></a><pre>
@ARTICLE{Pierce98:ACReview,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Review of {A Theory of Objects}, by {A}badi and
                  {C}ardelli},
  YEAR = {1997},
  VOLUME = 40,
  NUMBER = 5,
  PAGES = {297--298},
  JOURNAL = {The Computer Journal},
  SOURCE = {Tom Melham},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYWORDS = {oop},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/ac-review.ps">http://www.cis.upenn.edu/~bcpierce/papers/ac-review.ps</a>}
}
</pre>
</p>
<p><a name="GhelliPierce95-OLD"></a><pre>
@ARTICLE{GhelliPierce95-OLD,
  AUTHOR = {Giorgio Ghelli and Benjamin Pierce},
  TITLE = {Bounded Existentials and Minimal Typing},
  YEAR = {1998},
  VOLUME = 193,
  PAGES = {75--96},
  JOURNAL = {Theoretical Computer Science},
  PLCLUB = {Yes},
  BCP = {Yes},
  NOTE = {Circulated in manuscript form in 1992}
}
</pre>
</p>
<p><a name="GhelliPierce95"></a><pre>
@MISC{GhelliPierce95,
  AUTHOR = {Giorgio Ghelli and Benjamin Pierce},
  TITLE = {Bounded Existentials and Minimal Typing},
  YEAR = {1992},
  NOTE = {Circulated in manuscript form. Full version in 
                  {\em Theoretical Computer Science}, 193(1--2):75--96, February 1998.},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {subtyping},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/exists.ps">http://www.cis.upenn.edu/~bcpierce/papers/exists.ps</a>}
}
</pre>
</p>
<p><a name="BalasubramaniamPierce98-TR"></a><pre>
@TECHREPORT{BalasubramaniamPierce98-TR,
  AUTHOR = {S. Balasubramaniam and Benjamin C. Pierce},
  TITLE = {File Synchronization},
  INSTITUTION = {Computer Science Department, Indiana University},
  SERIES = {CSCI},
  NUMBER = {507},
  MONTH = APR,
  YEAR = 1998,
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceTurner:LTI"></a><pre>
@INPROCEEDINGS{PierceTurner:LTI,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Local Type Inference},
  YEAR = 1998,
  BOOKTITLE = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), San Diego, California},
  NOTE = {Full version in \bgroup\em ACM Transactions on Programming
                  Languages and Systems (TOPLAS)\egroup, 22(1), January 2000,
                  pp.~1--44},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {inference},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lti.ps">http://www.cis.upenn.edu/~bcpierce/papers/lti.ps</a>},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lti-popl.ps">http://www.cis.upenn.edu/~bcpierce/papers/lti-popl.ps</a>},
  FULL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/lti-toplas.ps">http://www.cis.upenn.edu/~bcpierce/papers/lti-toplas.ps</a>}
}
</pre>
</p>
<p><a name="HofmannPierce:TD"></a><pre>
@INPROCEEDINGS{HofmannPierce:TD,
  AUTHOR = {Martin Hofmann and Benjamin C. Pierce},
  TITLE = {Type Destructors},
  BOOKTITLE = {Informal proceedings of the Fourth International Workshop
                  on Foundations of Object-Oriented Languages (FOOL)},
  EDITOR = {Didier R\'e{}my},
  MONTH = JAN,
  YEAR = {1998},
  NOTE = {Full version in {\em Information and Computation}, 172(1)29--62 (2002)},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {oop},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/td.ps">http://www.cis.upenn.edu/~bcpierce/papers/td.ps</a>}
}
</pre>
</p>
<p><a name="Pierce:CONCUR-tutorial"></a><pre>
@MISC{Pierce:CONCUR-tutorial,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Type Systems for Concurrent Calculi},
  MONTH = SEP,
  YEAR = {1998},
  NOTE = {Invited tutorial at {\em CONCUR}, Nice, France},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="BunemanPierce99"></a><pre>
@INCOLLECTION{BunemanPierce99,
  AUTHOR = {Peter Buneman and Benjamin Pierce},
  BOOKTITLE = {Internet Programming Languages},
  TITLE = {Union Types for Semistructured Data},
  YEAR = {1998},
  MONTH = SEP,
  PUBLISHER = {Springer-Verlag},
  NOTE = {Proceedings of the International Database Programming
                  Languages Workshop. LNCS 1686},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {xduce},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/utssd.ps">http://www.cis.upenn.edu/~bcpierce/papers/utssd.ps</a>}
}
</pre>
</p>
<p><a name="BalasubramaniamPierce98"></a><pre>
@INPROCEEDINGS{BalasubramaniamPierce98,
  AUTHOR = {S. Balasubramaniam and Benjamin C. Pierce},
  TITLE = {What is a file synchronizer?},
  BOOKTITLE = {Fourth Annual ACM/IEEE International Conference on Mobile
                  Computing and Networking (MobiCom '98)},
  MONTH = OCT,
  YEAR = 1998,
  NOTE = {Full version available as Indiana University CSCI
                  technical report \#507, April 1998},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/snc-mobicom.ps">http://www.cis.upenn.edu/~bcpierce/papers/snc-mobicom.ps</a>},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/snc.ps">http://www.cis.upenn.edu/~bcpierce/papers/snc.ps</a>},
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/snc-slides.ps">http://www.cis.upenn.edu/~bcpierce/papers/snc-slides.ps</a>},
  KEYS = {unison},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce:GlobalComputingFoolTalk"></a><pre>
@MISC{Pierce:GlobalComputingFoolTalk,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Global Computing: Some Questions for {FOOLs}},
  SLIDES = {<a href="./gc-fool-slides.ps">gc-fool-slides.ps</a>},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {concurrencysurveys},
  NOTE = {Invited talk at FOOL workshop},
  YEAR = 2001
}
</pre>
</p>
<p><a name="Pierce:TypeSystemsForConcurrencyTalk"></a><pre>
@MISC{Pierce:TypeSystemsForConcurrencyTalk,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Type Systems for Concurrent Calculi},
  SLIDES = {<a href="./concur98.ps">concur98.ps</a>},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {concurrencysurveys},
  NOTE = {Invited tutorial at CONCUR},
  YEAR = 1998
}
</pre>
</p>
<p><a name="Pierce:FileSyncTheoryAndPracticeSlides"></a><pre>
@MISC{Pierce:FileSyncTheoryAndPracticeSlides,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {File Synchronization: Theory and Practice},
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/new-snc-slides.ps">http://www.cis.upenn.edu/~bcpierce/papers/new-snc-slides.ps</a>},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {unison},
  YEAR = 2001
}
</pre>
</p>
<p><a name="Pierce:UnisonAFileSync-Slides"></a><pre>
@MISC{Pierce:UnisonAFileSync-Slides,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Unison: A file synchronizer and its specification},
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/snc-tacs-2001Oct.ps">http://www.cis.upenn.edu/~bcpierce/papers/snc-tacs-2001Oct.ps</a>},
  NOTE = {Invited talk at {\em Theoretical Aspects of Computer Software} 
                  (TACS), Sendai, Japan},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {unison},
  YEAR = 2001
}
</pre>
</p>
<p><a name="Pierce:snc"></a><pre>
@MISC{Pierce:snc,
  AUTHOR = {Benjamin C. Pierce and Sundar Balasubramaniam, Trevor Jim
                  and Insup Lee and Insik Shin},
  TITLE = {{\sc Snc}: a file synchronizer},
  YEAR = {1998},
  NOTE = {(Superseded by {\sc Unison}.)},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="IgarashiPierceWadler99"></a><pre>
@INPROCEEDINGS{IgarashiPierceWadler99,
  AUTHOR = {Atsushi Igarashi and Benjamin Pierce and Philip Wadler},
  TITLE = {Featherweight {J}ava: {A} Minimal Core Calculus for {J}ava
                  and {GJ}},
  MONTH = OCT,
  BOOKTITLE = {{ACM} {SIGPLAN} {C}onference on {O}bject {O}riented {P}rogramming:
                    {S}ystems, {L}anguages, and {A}pplications ({OOPSLA})},
  YEAR = {1999},
  NOTE = {Full version in ACM Transactions on Programming
                  Languages and Systems (TOPLAS), 23(3), May 2001},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {oop},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fj-oopsla.ps">http://www.cis.upenn.edu/~bcpierce/papers/fj-oopsla.ps</a>},
  FULL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/fj-toplas.pdf">http://www.cis.upenn.edu/~bcpierce/papers/fj-toplas.pdf</a>}
}
</pre>
</p>
<p><a name="IgarashiPierce99"></a><pre>
@INPROCEEDINGS{IgarashiPierce99,
  AUTHOR = {Atsushi Igarashi and Benjamin C. Pierce},
  TITLE = {Foundations for Virtual Types},
  MONTH = JUN,
  YEAR = 1999,
  BOOKTITLE = {European Conference on Object-Oriented Programming (ECOOP), Lisbon, Portugal},
  NOTE = {Also in informal proceedings of the 
                  {\em Workshop on Foundations of Object-Oriented Languages
                  (FOOL)}, January 1999. Full version in {\em Information and
                  Computation}, 175(1): 34--49, May 2002},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {oop},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/vt.ps">http://www.cis.upenn.edu/~bcpierce/papers/vt.ps</a>}
}
</pre>
</p>
<p><a name="HosoyaPierce99"></a><pre>
@TECHREPORT{HosoyaPierce99,
  AUTHOR = {Haruo Hosoya and Benjamin C. Pierce},
  TITLE = {How Good is Local Type Inference?},
  INSTITUTION = {University of Pennsylvania},
  NUMBER = {MS-CIS-99-17},
  MONTH = JUN,
  YEAR = 1999,
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {inference},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/hgilti.ps">http://www.cis.upenn.edu/~bcpierce/papers/hgilti.ps</a>}
}
</pre>
</p>
<p><a name="KobayashiPierceTurner:LinearPi:TOPLAS"></a><pre>
@ARTICLE{KobayashiPierceTurner:LinearPi:TOPLAS,
  AUTHOR = {Naoki Kobayashi and Benjamin C. Pierce and David N.
                  Turner},
  TITLE = {Linearity and the {Pi-Calculus}},
  JOURNAL = {ACM Transactions on Programming Languages and Systems},
  VOLUME = {21},
  NUMBER = {5},
  PAGES = {914--947},
  MONTH = SEP,
  YEAR = {1999},
  CODEN = {ATPSDT},
  FULLISSN = {0164-0925},
  BIBDATE = {Tue Sep 26 10:12:58 MDT 2000},
  SOURCE = {TOPLAS db},
  NOTE = {Summary in POPL 1996.},
  KEYS = {pi},
  FULL = {<a href="http://www.acm.org/pubs/articles/journals/toplas/1999-21-5/p914-kobayashi/p914-kobayashi.pdf;
                  http://www.acm.org/pubs/citations/journals/toplas/1999-21-5/p914-kobayashi/">http://www.acm.org/pubs/articles/journals/toplas/1999-21-5/p914-kobayashi/p914-kobayashi.pdf;
                  http://www.acm.org/pubs/citations/journals/toplas/1999-21-5/p914-kobayashi/</a>},
  ABSTRACT = {The economy and flexibility of the pi-calculus make it an
                  attractive object of theoretical study and a clean basis
                  for concurrent language design and implementation. However,
                  such generality has a cost: encoding higher-level features
                  like functional computation in pi-calculus throws away
                  potentially useful information. We show how a linear type
                  system can be used to recover important static information
                  about a process's behavior. In particular, we can guarantee
                  that two processes communicating over a linear channel
                  cannot interfere with other communicating processes. After
                  developing standard results such as soundness of typing, we
                  focus on equivalences, adapting the standard notion of
                  barbed bisimulation to the linear setting and showing how
                  reductions on linear channels induce a useful ``partial
                  confluence'' of process behaviors. For an extended example
                  of the theory, we prove the validity of a tail-call
                  optimization for higher-order functions represented as
                  processes.},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="SewellWojciechowskiPierce98"></a><pre>
@INPROCEEDINGS{SewellWojciechowskiPierce98,
  AUTHOR = {Peter Sewell and Pawel Wojciechowski and Benjamin Pierce},
  TITLE = {Location Independence for Mobile Agents},
  BOOKTITLE = {Proceedings of {ICCL} '98},
  EDITOR = {H. E. Bal and B. Belkhouche and L. Cardelli},
  VOLUME = {1686},
  SERIES = {lncs},
  PUBLISHER = {Springer-Verlag},
  MONTH = SEP,
  YEAR = {1999},
  NOTE = {An earlier version with title {\em Location-Independent
                  Communication for Mobile Agents: a Two-Level
                  Architecture\/} appeared as Technical Report 462, Computer
                  Laboratory, University of Cambridge, April 1999},
  PLCLUB = {Yes},
  BCP = {Yes},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/wipl.ps">http://www.cis.upenn.edu/~bcpierce/papers/wipl.ps</a>},
  OFFICIAL = {<a href="http://link.springer.de/link/service/series/0558/bibs/1686/16860001.htm">http://link.springer.de/link/service/series/0558/bibs/1686/16860001.htm</a>},
  KEYS = {mobileagents}
}
</pre>
</p>
<p><a name="SewellWojciechowskiPierce98:TR"></a><pre>
@TECHREPORT{SewellWojciechowskiPierce98:TR,
  AUTHOR = {Peter Sewell and Pawe{\l} T. Wojciechowski and Benjamin C.
                  Pierce},
  TITLE = {Location-Independent Communication for Mobile Agents: a
                  Two-Level Architecture},
  INSTITUTION = {Computer Laboratory, University of Cambridge},
  YEAR = {1999},
  NUMBER = {462},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="SahuguetPierceTannen2000"></a><pre>
@MISC{SahuguetPierceTannen2000,
  AUTHOR = {Arnaud Sahuguet and Benjamin Pierce and Val Tannen},
  TITLE = {Chaining, Referral, Subscription, Leasing: New Mechanisms
                  in Distributed Query Optimization},
  MONTH = FEB,
  YEAR = {2000},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="SahuguetPierceTannen2000a"></a><pre>
@MISC{SahuguetPierceTannen2000a,
  AUTHOR = {Arnaud Sahuguet and Benjamin Pierce and Val Tannen},
  TITLE = {Distributed Query Optimization: Can Mobile Agents Help?},
  MONTH = FEB,
  YEAR = {2000},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="SewellWojciechowskiPierce98:old"></a><pre>
@INPROCEEDINGS{SewellWojciechowskiPierce98:old,
  AUTHOR = {Peter Sewell and Pawel T. Wojciechowski and Benjamin C.
                  Pierce},
  TITLE = {Location Independence for Mobile Agents},
  YEAR = 2000,
  NOTE = {To appear in an edited collection of papers (in Springer
                  LNCS) from the {\em Workshop on Internet Programming
                  Languages}, June 1998, Loyola University},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="Pierce:ICFP-invited"></a><pre>
@MISC{Pierce:ICFP-invited,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Module Systems: A Guide for the Perplexed},
  MONTH = SEP,
  YEAR = {2000},
  NOTE = {Invited talk at {\em ICFP}, Montreal},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="IgarashiPierce99:FJI"></a><pre>
@ARTICLE{IgarashiPierce99:FJI,
  AUTHOR = {Atsushi Igarashi and Benjamin C. Pierce},
  TITLE = {On Inner Classes},
  JOURNAL = {Information and Computation},
  YEAR = 2002,
  VOLUME = 177,
  NUMBER = 1,
  PAGES = {56--89},
  MONTH = AUG,
  NOTE = {A special issue with papers from the 7th International Workshop on Foundations of Object-Oriented Languages (FOOL){\rm, informal proceedings}.  An earlier 
                  version appeared in \emph \bgroup Proceedings of the 14th European Conference on Object-Oriented Programming (ECOOP)\egroup, Springer LNCS 1850, pages
                  129--153},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {oop},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/fji.ps">http://www.cis.upenn.edu/~bcpierce/fji.ps</a>},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/fji-tr.ps">http://www.cis.upenn.edu/~bcpierce/fji-tr.ps</a>}
}
</pre>
</p>
<p><a name="PierceTurner:PictDesign"></a><pre>
@INCOLLECTION{PierceTurner:PictDesign,
  AUTHOR = {Benjamin C. Pierce and David N. Turner},
  TITLE = {Pict: A Programming Language Based on the Pi-Calculus},
  YEAR = {2000},
  BOOKTITLE = {Proof, Language and Interaction: Essays in Honour of Robin
                  Milner},
  EDITOR = {Gordon Plotkin and Colin Stirling and Mads Tofte},
  PUBLISHER = {MIT Press},
  PAGES = {455--494},
  CHECKED = {Yes},
  PLCLUB = {Yes},
  BCP = {Yes},
  FULL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/pict-design.ps">http://www.cis.upenn.edu/~bcpierce/papers/pict-design.ps</a>},
  KEYS = {pi}
}
</pre>
</p>
<p><a name="GapeyevLevinPierce2000"></a><pre>
@ARTICLE{GapeyevLevinPierce2000,
  AUTHOR = {Vladimir Gapeyev and Michael Levin and Benjamin Pierce},
  TITLE = {Recursive Subtyping Revealed},
  JOURNAL = {Journal of Functional Programming},
  VOLUME = 12,
  NUMBER = 6,
  PAGES = {511--548},
  CHECKED = {Yes},
  YEAR = {2003},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {subtyping},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/rsr.ps">http://www.cis.upenn.edu/~bcpierce/papers/rsr.ps</a>},
  NOTE = {Preliminary version in {\em International Conference on
                  Functional Programming (ICFP)}, 2000.  Also appears as
                  Chapter 21 of {\em Types and Programming Languages}
                  by Benjamin C. Pierce (MIT Press, 2002).}
}
</pre>
</p>
<p><a name="GapeyevLevinPierce2000:ICFP"></a><pre>
@INPROCEEDINGS{GapeyevLevinPierce2000:ICFP,
  AUTHOR = {Vladimir Gapeyev and Michael Levin and Benjamin Pierce},
  TITLE = {Recursive Subtyping Revealed},
  BOOKTITLE = {{ACM} {SIGPLAN} {I}nternational {C}onference on {F}unctional {P}rogramming
                    ({ICFP}), Montreal, Canada},
  YEAR = {2000},
  PLCLUB = {Yes},
  BCP = {Yes},
  NOTE = {To appear in {\em Journal of Functional Programming}}
}
</pre>
</p>
<p><a name="PierceSumii00"></a><pre>
@MISC{PierceSumii00,
  AUTHOR = {Benjamin Pierce and Eijiro Sumii},
  TITLE = {Relating Cryptography and Polymorphism},
  MONTH = JUL,
  YEAR = {2000},
  PLCLUB = {Yes},
  BCP = {Yes},
  NOTE = {Some parts superceded by \cite{SumiiPierce01}},
  KEYS = {security},
  MANUSCRIPT = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/infohide.ps">http://www.cis.upenn.edu/~bcpierce/papers/infohide.ps</a>}
}
</pre>
</p>
<p><a name="LevinPierce99:OLD1"></a><pre>
@TECHREPORT{LevinPierce99:OLD1,
  AUTHOR = {Michael Y. Levin and Benjamin C. Pierce},
  TITLE = {TinkerType: {A} Language for Playing with Formal Systems},
  MONTH = JUN,
  YEAR = {2000},
  BOOKTITLE = {Logical Frameworks and Metalanguages},
  NOTE = {Invited talk (submitted for journal publication)},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="HosoyaPierce2000"></a><pre>
@INPROCEEDINGS{HosoyaPierce2000,
  AUTHOR = {Haruo Hosoya and Benjamin C. Pierce},
  TITLE = {{XDuce}: A Typed {XML} Processing Language (Preliminary
                  Report)},
  BOOKTITLE = {International Workshop on the Web and Databases (WebDB)},
  EDITOR = {Dan Suciu and Gottfried Vossen},
  MONTH = MAY,
  YEAR = {2000},
  NOTE = {Reprinted in {\em The Web and Databases, Selected Papers},
                  Springer LNCS volume 1997, 2001},
  KEYS = {xduce},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xduce-prelim.ps">http://www.cis.upenn.edu/~bcpierce/papers/xduce-prelim.ps</a>},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="IgarashiPierceWadler01"></a><pre>
@INPROCEEDINGS{IgarashiPierceWadler01,
  AUTHOR = {Atsushi Igarashi and Benjamin C. Pierce and Philip Wadler},
  TITLE = {A Recipe for Raw Types},
  YEAR = 2001,
  BOOKTITLE = {Workshop on Foundations of Object-Oriented Languages
                  (FOOL)},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {oop},
  SHORT = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/rfgj.ps">http://www.cis.upenn.edu/~bcpierce/papers/rfgj.ps</a>}
}
</pre>
</p>
<p><a name="BruceCardelliPierce96"></a><pre>
@ARTICLE{BruceCardelliPierce96,
  AUTHOR = {Kim B. Bruce and Luca Cardelli and Benjamin C. Pierce},
  TITLE = {Comparing Object Encodings},
  JOURNAL = {Information and Computation},
  YEAR = 1999,
  MONTH = NOV,
  VOLUME = 155,
  NUMBER = {1/2},
  PAGES = {108--133},
  NOTE = {Special issue of papers from {\em
                  Theoretical Aspects of Computer Software (TACS 1997)}.
                  An earlier version appeared as an invited
                  lecture in the Third International Workshop on Foundations
                  of Object Oriented Languages (FOOL 3), July 1996},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {oop},
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/compobj.ps">http://www.cis.upenn.edu/~bcpierce/papers/compobj.ps</a>}
}
</pre>
</p>
<p><a name="JimPierceVouillon:UnisonSys"></a><pre>
@UNPUBLISHED{JimPierceVouillon:UnisonSys,
  AUTHOR = {Trevor Jim and Benjamin C. Pierce and J\'er\^ome Vouillon},
  TITLE = {How to Build a File Synchronizer},
  YEAR = {2003},
  NOTE = {Manuscript},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="SumiiPierce01"></a><pre>
@ARTICLE{SumiiPierce01,
  AUTHOR = {Eijiro Sumii and Benjamin C. Pierce},
  TITLE = {Logical Relations for Encryption},
  JOURNAL = {Journal of Computer Security},
  YEAR = {2003},
  VOLUME = {11},
  NUMBER = {4},
  PAGES = {521--554},
  PLCLUB = {Yes},
  BCP = {Yes},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/infohide2.ps">http://www.cis.upenn.edu/~bcpierce/papers/infohide2.ps</a>},
  KEYS = {security},
  NOTE = {Extended abstract appeared in {\emph{14th IEEE Computer Security Foundations Workshop}}, pp.~256--269, 2001.}
}
</pre>
</p>
<p><a name="HosoyaPierce2001"></a><pre>
@INPROCEEDINGS{HosoyaPierce2001,
  AUTHOR = {Haruo Hosoya and Benjamin C. Pierce},
  TITLE = {Regular Expression Pattern Matching},
  BOOKTITLE = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), London, England},
  YEAR = {2001},
  PLCLUB = {Yes},
  BCP = {Yes},
  CHECKED = {Yes},
  NOTE = {Full version in {\em Journal of
                  Functional Programming}, 13(6), Nov. 2003, pp. 961--1004},
  FULL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tapat.ps">http://www.cis.upenn.edu/~bcpierce/papers/tapat.ps</a>},
  KEYS = {xduce}
}
</pre>
</p>
<p><a name="HosoyaVouillonPierce2000"></a><pre>
@ARTICLE{HosoyaVouillonPierce2000,
  AUTHOR = {Haruo Hosoya and J\'er\^ome Vouillon and Benjamin C.
                  Pierce},
  TITLE = {Regular Expression Types for {XML}},
  JOURNAL = {ACM Transactions on Programming Languages and Systems
                  (TOPLAS)},
  YEAR = {2005},
  MONTH = JAN,
  VOLUME = 27,
  NUMBER = 1,
  PAGES = {46--90},
  NOTE = {Preliminary version in ICFP 2000},
  PLCLUB = {Yes},
  BCP = {Yes},
  CHECKED = {Yes},
  KEYS = {xduce},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/regsub.ps">http://www.cis.upenn.edu/~bcpierce/papers/regsub.ps</a>},
  FULL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/regsub-toplas.pdf">http://www.cis.upenn.edu/~bcpierce/papers/regsub-toplas.pdf</a>}
}
</pre>
</p>
<p><a name="HosoyaPierce2002"></a><pre>
@ARTICLE{HosoyaPierce2002,
  AUTHOR = {Haruo Hosoya and Benjamin C. Pierce},
  TITLE = {{XDuce}: A Statically Typed {XML} Processing Language},
  JOURNAL = {ACM Transactions on Internet Technology},
  YEAR = {2003},
  VOLUME = 3,
  NUMBER = 2,
  MONTH = MAY,
  PAGES = {117--148},
  CHECKED = {Yes},
  OFFICIAL = {<a href="http://doi.acm.org/10.1145/767193.767195">http://doi.acm.org/10.1145/767193.767195</a>},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {xduce}
}
</pre>
</p>
<p><a name="Pierce-Sumii-01"></a><pre>
@INPROCEEDINGS{Pierce-Sumii-01,
  AUTHOR = {Eijiro Sumii and Benjamin Pierce},
  TITLE = {The Cryptographic {$\lambda$}-Calculus: Syntax, Semantics,
                  Type System and Logical Relation (in Japanese)},
  BOOKTITLE = {Informal Proceedings of JSSST Workshop on Programming and 
                  Programming Languages (PPL2001)},
  YEAR = {2001},
  NOTE = {Best paper prize},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="XtaticCompiler"></a><pre>
@MISC{XtaticCompiler,
  AUTHOR = {Vladimir Gapeyev and Michael Y. Levin and Benjamin C. Pierce and Alan Schmitt},
  TITLE = {The {X}tatic Compiler and Runtime System},
  YEAR = {2005},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {xtatic},
  SOURCES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic.tgz">http://www.cis.upenn.edu/~bcpierce/papers/xtatic.tgz</a>}
}
</pre>
</p>
<p><a name="GapeyevPierce03"></a><pre>
@INPROCEEDINGS{GapeyevPierce03,
  AUTHOR = {Vladimir Gapeyev and Benjamin C. Pierce},
  TITLE = {Regular Object Types},
  BOOKTITLE = {European Conference on Object-Oriented Programming (ECOOP), Darmstadt, Germany},
  YEAR = {2003},
  NOTE = {A preliminary version was presented at FOOL '03},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {xtatic},
  SHORT = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/regobj.pdf">http://www.cis.upenn.edu/~bcpierce/papers/regobj.pdf</a>},
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/regobj-ecoop-slides.ps">http://www.cis.upenn.edu/~bcpierce/papers/regobj-ecoop-slides.ps</a>}
}
</pre>
</p>
<p><a name="LevinPierce99"></a><pre>
@ARTICLE{LevinPierce99,
  AUTHOR = {Michael Y. Levin and Benjamin C. Pierce},
  TITLE = {TinkerType: {A} Language for Playing with Formal Systems},
  JOURNAL = {Journal of Functional Programming},
  VOLUME = 13,
  NUMBER = 2,
  MONTH = MAR,
  YEAR = {2003},
  NOTE = {A preliminary version appeared as an invited
                  paper at the {\em Logical Frameworks and Metalanguages
                  Workshop (LFM)}, June 2000},
  PLCLUB = {Yes},
  BCP = {Yes},
  FULL = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tt-jfp.pdf">http://www.cis.upenn.edu/~bcpierce/papers/tt-jfp.pdf</a>},
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tt-slides.ps">http://www.cis.upenn.edu/~bcpierce/papers/tt-slides.ps</a>},
  SOURCES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tt.tar.gz">http://www.cis.upenn.edu/~bcpierce/papers/tt.tar.gz</a>},
  KEYS = {modular}
}
</pre>
</p>
<p><a name="PierceVouillon:UnisonSpec"></a><pre>
@UNPUBLISHED{PierceVouillon:UnisonSpec,
  AUTHOR = {Benjamin C. Pierce and J\'er\^ome Vouillon},
  TITLE = {Unison: A File Synchronizer and its Specification},
  YEAR = {2001},
  NOTE = {Manuscript},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="PierceVouillon:UnisonSpecTR"></a><pre>
@TECHREPORT{PierceVouillon:UnisonSpecTR,
  AUTHOR = {Benjamin C. Pierce and J\'er\^ome Vouillon},
  TITLE = {What's in {U}nison? {A} Formal
                  Specification and Reference Implementation 
                  of a File Synchronizer},
  YEAR = {2004},
  INSTITUTION = {Dept. of Computer and Information Science, University of Pennsylvania},
  NUMBER = {MS-CIS-03-36},
  PLCLUB = {Yes},
  BCP = {Yes},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/unisonspec.pdf">http://www.cis.upenn.edu/~bcpierce/papers/unisonspec.pdf</a>},
  KEYS = {unison}
}
</pre>
</p>
<p><a name="Pierce:TypeSystems"></a><pre>
@BOOK{Pierce:TypeSystems,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Types and Programming Languages},
  PUBLISHER = {MIT Press},
  YEAR = 2002,
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {books},
  HOMEPAGE = {<a href="http://www.cis.upenn.edu/~bcpierce/tapl">http://www.cis.upenn.edu/~bcpierce/tapl</a>},
  ERRATA = {<a href="http://www.cis.upenn.edu/~bcpierce/tapl/errata.txt">http://www.cis.upenn.edu/~bcpierce/tapl/errata.txt</a>}
}
</pre>
</p>
<p><a name="ATTAPL"></a><pre>
@BOOK{ATTAPL,
  EDITOR = {Benjamin C. Pierce},
  TITLE = {Advanced Topics in Types and Programming Languages},
  PUBLISHER = {MIT Press},
  YEAR = 2005,
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {books},
  HOMEPAGE = {<a href="http://www.cis.upenn.edu/~bcpierce/attapl">http://www.cis.upenn.edu/~bcpierce/attapl</a>}
}
</pre>
</p>
<p><a name="ISSS2002"></a><pre>
@PROCEEDINGS{ISSS2002,
  TITLE = {Software Security -- Theories and Systems},
  EDITOR = {M. Okada and B. Pierce and A. Scedrov and H. Tokuda 
                  and A. Yonezawa},
  SERIES = {Lecture Notes in Computer Science},
  NUMBER = {2609},
  PUBLISHER = {Springer-Verlag},
  OPTADDRESS = {Berlin},
  YEAR = {2003},
  NOTE = {Revised papers from the Mext-NSF-JSPS {\em International 
                  Symposium on Software Security}, Tokyo, Japan, 
                  November 8-10, 2002},
  ISBN = {3-540-00708-3},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="TACS2001"></a><pre>
@PROCEEDINGS{TACS2001,
  TITLE = {Theoretical Aspects of
                  Computer Software (TACS), 4th International Symposium},
  EDITOR = {Naoki Kobayashi and Benjamin C. Pierce},
  SERIES = {Lecture Notes in Computer Science},
  NUMBER = {2215},
  PUBLISHER = {Springer-Verlag},
  OPTADDRESS = {Berlin},
  YEAR = {2001},
  LOCATION = {Sendai, Japan, October 29-31, 2001},
  ISBN = {3-540-42736-8},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="LensesandUpdates2003"></a><pre>
@UNPUBLISHED{LensesandUpdates2003,
  AUTHOR = {Benjamin C. Pierce and Alan Schmitt},
  TITLE = {Lenses and View Update Translation},
  YEAR = {2003},
  NOTE = {Manuscript},
  MANUSCRIPT = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/dblenses.pdf">http://www.cis.upenn.edu/~bcpierce/papers/dblenses.pdf</a>},
  KEYS = {harmony},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="nwaysync"></a><pre>
@UNPUBLISHED{nwaysync,
  AUTHOR = {Michael B. Greenwald and Sanjeev Khanna and 
                  Keshav Kunal and Benjamin C. Pierce and Alan Schmitt},
  TITLE = {Agreement is Quicker than Domination: Conflict Resolution for
                  Optimistically Replicated Data},
  YEAR = 2005,
  NOTE = {Submitted for publication; available electronically},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {harmony},
  SHORT = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/nway-short.pdf">http://www.cis.upenn.edu/~bcpierce/papers/nway-short.pdf</a>}
}
</pre>
</p>
<p><a name="Focal2005"></a><pre>
@INPROCEEDINGS{Focal2005,
  AUTHOR = {J. Nathan Foster and Michael B. Greenwald and Jonathan T. Moore 
                  and Benjamin C. Pierce and Alan Schmitt},
  TITLE = {Combinators for Bi-Directional Tree Transformations: 
                  {A} Linguistic Approach to the View Update Problem},
  BOOKTITLE = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Long Beach, California},
  YEAR = {2005},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/newlenses-popl.pdf">http://www.cis.upenn.edu/~bcpierce/papers/newlenses-popl.pdf</a>},
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/newlenses-popl-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/newlenses-popl-slides.pdf</a>},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/newlenses-full.pdf">http://www.cis.upenn.edu/~bcpierce/papers/newlenses-full.pdf</a>},
  NOTE = {Extended version available as University of Pennsylvania 
                  technical report MS-CIS-03-08.  Earlier version presented at 
                  the {\em Workshop on Programming Language Technologies for 
                  XML (PLAN-X)}, 2004},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {harmony}
}
</pre>
</p>
<p><a name="Pierce:NEPLS2004"></a><pre>
@MISC{Pierce:NEPLS2004,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Combinators for Bi-Directional Tree Transformations: 
                  {A} Linguistic Approach to the View Update Problem},
  MONTH = OCT,
  YEAR = 2004,
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/newlenses-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/newlenses-slides.pdf</a>},
  NOTE = {Invited talk at {\em New England Programming Languages Symposium}},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {harmony}
}
</pre>
</p>
<p><a name="Pierce:LinksTalk2005"></a><pre>
@MISC{Pierce:LinksTalk2005,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Fancy Types for XML: Friend or Foe?},
  MONTH = APR,
  YEAR = 2005,
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/linkstalk-200504.pdf">http://www.cis.upenn.edu/~bcpierce/papers/linkstalk-200504.pdf</a>},
  NOTE = {Talk at {\em LINKS} workshop, April 2005},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {xtatic}
}
</pre>
</p>
<p><a name="Pierce:HarmonyTalkTGC"></a><pre>
@MISC{Pierce:HarmonyTalkTGC,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Harmony: {T}he Art of Reconciliation},
  MONTH = APR,
  YEAR = 2005,
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/harmony-tgc-talk-2005.pdf">http://www.cis.upenn.edu/~bcpierce/papers/harmony-tgc-talk-2005.pdf</a>},
  NOTE = {Invited talk at {\em Trusted Global Computing} conference, 
                  April 2005},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {harmony}
}
</pre>
</p>
<p><a name="Pierce:HarmonyTalk2003"></a><pre>
@MISC{Pierce:HarmonyTalk2003,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Harmony: A Synchronization Framework for Tree-Structured Data},
  MONTH = SEP,
  YEAR = 2003,
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/harmonyslides-2003aug.pdf">http://www.cis.upenn.edu/~bcpierce/papers/harmonyslides-2003aug.pdf</a>},
  NOTE = {Slides from a talk presented in several places
                  (Cambridge, Edinburgh, 
                  Philadelphia, Princeton) in Fall 2003},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {harmony}
}
</pre>
</p>
<p><a name="Pierce:EPFLTalk2002"></a><pre>
@MISC{Pierce:EPFLTalk2002,
  AUTHOR = {Benjamin C. Pierce},
  TITLE = {Synchronize globally, compute locally},
  MONTH = JUL,
  YEAR = 2002,
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/harmonyslides-epfl.ps">http://www.cis.upenn.edu/~bcpierce/papers/harmonyslides-epfl.ps</a>},
  NOTE = {Keynote address at {\em Research Day on Global Computing}, 
                  EFPL, Lausanne},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {harmony}
}
</pre>
</p>
<p><a name="HocusFocusTR2003-old"></a><pre>
@TECHREPORT{HocusFocusTR2003-old,
  AUTHOR = {Michael B. Greenwald and Jonathan T. Moore and Benjamin C. Pierce
                  and Alan Schmitt},
  TITLE = {A Language for Bi-Directional Tree Transformations},
  YEAR = 2003,
  TYPE = {Technical Report},
  NUMBER = {MS-CIS-03-08},
  INSTITUTION = {               University of Pennsylvania},
  PLCLUB = {Yes},
  BCP = {Yes},
  NOTE = {Revised April 2004}
}
</pre>
</p>
<p><a name="HarmonyOverview"></a><pre>
@TECHREPORT{HarmonyOverview,
  AUTHOR = {Benjamin C. Pierce and Alan Schmitt and Michael B. Greenwald},
  TITLE = {Bringing {H}armony to Optimism:
                  {A} Synchronization Framework for Heterogeneous 
                  Tree-Structured Data},
  YEAR = 2003,
  TYPE = {Technical Report},
  NUMBER = {MS-CIS-03-42},
  INSTITUTION = {University of Pennsylvania},
  PLCLUB = {Yes},
  BCP = {Yes},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/harmony-sync-tr.pdf">http://www.cis.upenn.edu/~bcpierce/papers/harmony-sync-tr.pdf</a>},
  KEYS = {harmony},
  NOTE = {Superceded by MS-CIS-05-02}
}
</pre>
</p>
<p><a name="SYNCTR2005"></a><pre>
@TECHREPORT{SYNCTR2005,
  AUTHOR = {J. Nathan Foster and Michael B. Greenwald and Christian Kirkegaard
                  and Benjamin C. Pierce and Alan Schmitt},
  TITLE = {Schema-Directed Data Synchronization},
  MONTH = MAR,
  YEAR = 2005,
  TYPE = {Technical Report},
  NUMBER = {MS-CIS-05-02},
  INSTITUTION = {University of Pennsylvania},
  NOTE = {Supercedes MS-CIS-03-42},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/sync-tr.pdf">http://www.cis.upenn.edu/~bcpierce/papers/sync-tr.pdf</a>},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="SYNC2005"></a><pre>
@INPROCEEDINGS{SYNC2005,
  AUTHOR = {J. Nathan Foster and Michael B. Greenwald and Christian Kirkegaard
                  and Benjamin C. Pierce and Alan Schmitt},
  TITLE = {Exploiting Schemas in Data Synchronization},
  MONTH = AUG,
  YEAR = 2005,
  BOOKTITLE = {Database Programming Languages (DBPL)},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/sync-tr.pdf">http://www.cis.upenn.edu/~bcpierce/papers/sync-tr.pdf</a>},
  SHORT = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/sync-dbpl.pdf">http://www.cis.upenn.edu/~bcpierce/papers/sync-dbpl.pdf</a>},
  KEYS = {harmony},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="HocusFocus2003"></a><pre>
@UNPUBLISHED{HocusFocus2003,
  AUTHOR = {Michael B. Greenwald and Jonathan T. Moore and Benjamin C. Pierce
             and Alan Schmitt},
  TITLE = {A Language for Bi-Directional Tree Transformations},
  YEAR = 2003,
  INSTITUTION = {Department of Computer and Information Science, University of Pennsylvania},
  NOTE = {Manuscript; available at \url{http://www.cis.upenn.edu/~bcpierce/papers/lenses.pdf}},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="SumiiPierce2004"></a><pre>
@INPROCEEDINGS{SumiiPierce2004,
  AUTHOR = {Eijiro Sumii and Benjamin C. Pierce},
  TITLE = {A Bisimulation for Dynamic Sealing},
  BOOKTITLE = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Venice, Italy},
  YEAR = {2004},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {security},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/infohide3.pdf">http://www.cis.upenn.edu/~bcpierce/papers/infohide3.pdf</a>},
  NOTE = {Full version to appear in {\em Theoretical Computer Science}}
}
</pre>
</p>
<p><a name="SumiiPierce2005"></a><pre>
@INPROCEEDINGS{SumiiPierce2005,
  AUTHOR = {Eijiro Sumii and Benjamin C. Pierce},
  TITLE = {A Bisimulation for Type Abstraction and Recursion},
  BOOKTITLE = {{ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL}), Long Beach, California},
  YEAR = {2005},
  KEYS = {security},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/infohide5-popl.pdf">http://www.cis.upenn.edu/~bcpierce/papers/infohide5-popl.pdf</a>},
  PLCLUB = {Yes},
  BCP = {Yes}
}
</pre>
</p>
<p><a name="XtaticRuntime"></a><pre>
@INPROCEEDINGS{XtaticRuntime,
  TITLE = {{XML} Goes Native: {R}un-time Representations for {Xtatic}},
  AUTHOR = {Vladimir Gapeyev and Michael Y. Levin
                  and Benjamin C. Pierce and Alan Schmitt},
  YEAR = 2005,
  MONTH = APR,
  BOOKTITLE = {14th International Conference on Compiler Construction},
  CONF = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic-runtime-CC.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtatic-runtime-CC.pdf</a>},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic-runtime-TR.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtatic-runtime-TR.pdf</a>},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {xtatic}
}
</pre>
</p>
<p><a name="XtaticExperience"></a><pre>
@INPROCEEDINGS{XtaticExperience,
  TITLE = {The {Xtatic} Experience},
  AUTHOR = {Vladimir Gapeyev and Michael Y. Levin 
                  and Benjamin C. Pierce and Alan Schmitt},
  BOOKTITLE = {Workshop on Programming Language Technologies for XML (PLAN-X)},
  PLCLUB = {Yes},
  BCP = {Yes},
  MONTH = JAN,
  YEAR = 2005,
  NOTE = {University of Pennsylvania 
                  Technical Report MS-CIS-04-24, Oct 2004},
  KEYS = {xtatic},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic-experience-TR.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtatic-experience-TR.pdf</a>},
  SLIDES = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic-experience-slides.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtatic-experience-slides.pdf</a>}
}
</pre>
</p>
<p><a name="GapeyevPierce2004"></a><pre>
@TECHREPORT{GapeyevPierce2004,
  TITLE = {Paths into Patterns},
  AUTHOR = {Vladimir Gapeyev and Benjamin C. Pierce},
  YEAR = 2004,
  MONTH = OCT,
  TYPE = {Technical Report},
  NUMBER = {MS-CIS-04-25},
  INSTITUTION = {University of Pennsylvania},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {xtatic},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/xtatic-pathambig-TR.pdf">http://www.cis.upenn.edu/~bcpierce/papers/xtatic-pathambig-TR.pdf</a>}
}
</pre>
</p>
<p><a name="LevinPierce05TR"></a><pre>
@TECHREPORT{LevinPierce05TR,
  TITLE = {Type-based Optimization for Regular Patterns},
  AUTHOR = {Michael Y. Levin and Benjamin C. Pierce},
  YEAR = 2005,
  TYPE = {Technical Report},
  NUMBER = {MS-CIS-05-13},
  INSTITUTION = {University of Pennsylvania},
  MONTH = JUN,
  BCP = {Yes},
  KEYS = {xtatic},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tb-TR.pdf">http://www.cis.upenn.edu/~bcpierce/papers/tb-TR.pdf</a>}
}
</pre>
</p>
<p><a name="LevinPierce05"></a><pre>
@INPROCEEDINGS{LevinPierce05,
  TITLE = {Type-based Optimization for Regular Patterns},
  AUTHOR = {Michael Y. Levin and Benjamin C. Pierce},
  BOOKTITLE = {Database Programming Languages (DBPL)},
  YEAR = 2005,
  MONTH = AUG,
  BCP = {Yes},
  PLCLUB = {Yes},
  KEYS = {xtatic},
  TR = {<a href="http://www.cis.upenn.edu/~bcpierce/papers/tb-TR.pdf">http://www.cis.upenn.edu/~bcpierce/papers/tb-TR.pdf</a>}
}
</pre>
</p>
<p><a name="HosoyaPierceTurner98"></a><pre>
@UNPUBLISHED{HosoyaPierceTurner98,
  AUTHOR = {Haruo Hosoya and Benjamin C. Pierce and David N. Turner},
  TITLE = {Datatypes and Subtyping},
  NOTE = {Manuscript},
  PLCLUB = {Yes},
  BCP = {Yes},
  KEYS = {subtyping},
  YEAR = 1998,
  PS = {<a href="http://www.cis.upenn.edu/~bcpierce/ds.ps">http://www.cis.upenn.edu/~bcpierce/ds.ps</a>}
}
</pre>
</p>
<p><a name="POPL92"></a><pre>
@PROCEEDINGS{POPL92,
  TITLE = {Proceedings of the Nineteenth ACM Symposium on Principles
                  of Programming Languages (Albequerque, New Mexico)},
  BOOKTITLE = {Proceedings of the Nineteenth ACM Symposium on Principles
                  of Programming Languages (Albequerque, New Mexico)},
  MONTH = JAN,
  YEAR = 1992
}
</pre>
</p>
<pre>
@COMMENT{{{{This file has been generated by bib2bib 1.75}}
</pre>

<pre>
@COMMENT{{{{Command line: /usr/bin/bib2bib MS-CIS-03-26.bib MS-CIS-04-26.bib MS-CIS-05-04-corrected.bib MS-CIS-05-04.bib MS-CIS-05-05.bib MS-CIS-05-07.bib gadt.bib icfp2003-corrected.bib icfp2003.bib icfp2005.bib itrs2002.bib lics2005.bib poplmark.bib senior-thesis.bib tldi2005.bib tr-717-04.bib -ob /home/geoffw/svnroot/web/dest-official/research/papers/geoffw.bib}}
</pre>

<p><a name="Was+Wei:UPTR-2003"></a><pre>
@TECHREPORT{Was+Wei:UPTR-2003,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Boxes Go Bananas: Encoding higher-order abstract syntax with 
           parametric polymorphism (Extended Version)},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall, 
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2003,
  NUMBER = {MS-CIS-03-26},
  MONTH = {September},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-03-26.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-03-26.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
Higher-order abstract syntax is a simple technique for implementing
languages with functional programming.  Object variables and binders
are implemented by variables and binders in the host language.  By
using this technique, one can avoid implementing common and tricky
routines dealing with variables, such as capture-avoiding
substitution.  However, despite the advantages this technique
provides, it is not commonly used because it is difficult to write
sound elimination forms (such as folds or catamorphisms) for
higher-order abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.

In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals.  From
this implementation, we derive ``fusion laws'' that functional
programmers may use to reason about the iteration operator.  Finally,
we show how this use of parametric polymorphism corresponds to the
Sch\"urmann, Despeyroux and Pfenning method of enforcing
parametricity through modal types. We do so by using this library to
give a sound and complete encoding of their calculus into System
$\mathrm{F}_{\omega}$.  This encoding can serve as a starting point
for reasoning about higher-order structures in polymorphic languages.}
}
</pre>
</p>
<p><a name="Vyt+Was+Wei:UPTR-2004"></a><pre>
@TECHREPORT{Vyt+Was+Wei:UPTR-2004,
  AUTHOR = {Dimitrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich},
  TITLE = {An Open and Shut Typecase (Extended Version)},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall, 
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2004,
  NUMBER = {MS-CIS-04-26},
  MONTH = {November},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-04-26.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-04-26.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
Ad-hoc polymorphism is a compelling addition to typed programming
languages.  There are two different forms of ad-hoc polymorphism. With
the nominal form, the execution of an operation is determined solely
by the name of the type argument, whereas with the structural form,
operations are defined by case analysis on the structure of types.
The two forms differ in the way that they treat user-defined types.
Operations defined by the nominal approach are considered ``open''---the
programmer can add cases for new types without modifying existing
code. The operations must be extended however with specialized code for
the new types, and it may be tedious and even difficult to add extensions
that apply to a potentially large universe of user-defined types.
Structurally defined operations apply to new types by treating them as
equal to their underlying definitions, so no new cases for new types
are necessary. However this form is considered ``closed'' to extension,
as the behaviour of the operations cannot be differentiated for the
new types. This form destroys the distinctions that user-defined types
are designed to express.  Both approaches have their benefits, so it
is important to provide both capabilities in a single language that is
expressive enough to decouple the ``openness'' issue from the way that
user-defined types are treated. We present such a language that supports
both forms of ad-hoc polymorphism.
  }
}
</pre>
</p>
<p><a name="Was+Wei:UPTR-2005a"></a><pre>
@TECHREPORT{Was+Wei:UPTR-2005a,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Generalizing Parametricity Using Information Flow (Extended Version)},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall, 
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2005,
  NUMBER = {MS-CIS-05-04},
  MONTH = {June},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-04.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-04.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
Run-time type analysis allows programmers to easily and concisely define
operations based upon type structure, such as serialization, iterators,
and structural equality.  However, when types can be inspected at run
time, nothing is secret.  A module writer cannot use type abstraction
to hide implementation details from clients: clients can determine the
structure of these supposedly ``abstract'' data types.  Furthermore,
access control mechanisms do not help isolate the implementation of
abstract datatypes from their clients.  Buggy or malicious authorized
modules may leak type information to unauthorized clients, so module
implementors cannot reliably tell which parts of a program rely on their
type definitions.

Currently, module implementors rely on parametric polymorphism to provide
integrity and confidentiality guarantees about their abstract datatypes.
However, standard parametricity does not hold for languages with run-time
type analysis; this paper shows how to generalize parametricity so
that it does.   The key is to augment the type system with annotations
about information-flow.  Implementors can then easily see which parts
of a program depend on the chosen implementation by tracking the flow
of dynamic type information.},
  NOTE = {
     This some errors found in the original technical report. Generated August 2005.
  }
}
</pre>
</p>
<p><a name="Was+Wei:UPTR-2005"></a><pre>
@TECHREPORT{Was+Wei:UPTR-2005,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Generalizing Parametricity Using Information Flow (Extended Version)},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall, 
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2005,
  NUMBER = {MS-CIS-05-04},
  MONTH = {June},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-04.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-04.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
Run-time type analysis allows programmers to easily and concisely define
operations based upon type structure, such as serialization, iterators,
and structural equality.  However, when types can be inspected at run
time, nothing is secret.  A module writer cannot use type abstraction
to hide implementation details from clients: clients can determine the
structure of these supposedly ``abstract'' data types.  Furthermore,
access control mechanisms do not help isolate the implementation of
abstract datatypes from their clients.  Buggy or malicious authorized
modules may leak type information to unauthorized clients, so module
implementors cannot reliably tell which parts of a program rely on their
type definitions.

Currently, module implementors rely on parametric polymorphism to provide
integrity and confidentiality guarantees about their abstract datatypes.
However, standard parametricity does not hold for languages with run-time
type analysis; this paper shows how to generalize parametricity so
that it does.   The key is to augment the type system with annotations
about information-flow.  Implementors can then easily see which parts
of a program depend on the chosen implementation by tracking the flow
of dynamic type information.}
}
</pre>
</p>
<p><a name="Was:UPTR-2005"></a><pre>
@TECHREPORT{Was:UPTR-2005,
  AUTHOR = {Geoffrey Washburn},
  TITLE = {Cause and Effect: Type Systems for Effects and Dependencies},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall, 
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2005,
  NUMBER = {MS-CIS-05-05},
  MONTH = {July},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-05.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-05.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
Frameworks for formal reasoning about programs are important not only
for automated tools but also for programmers.   Type systems are a
popular framework both for documenting program interfaces and for
developing static analysis tools.  However, type systems commonly
used in practice today fail to capture essential aspects of program
behavior: The effects and dependencies of the programs.  In this paper,
we examine a prototypical effect type system in the style of Gifford
et al. and a canonical example of a dependency type system based upon
the work of Zdancewic.  Finally, we show how these two type systems
can be embedded in a more general framework, a monadic type system as
developed by Pfenning and Davies.      
  }
}
</pre>
</p>
<p><a name="Dan+Wal+Was+Wei:UPTR-2005"></a><pre>
@TECHREPORT{Dan+Wal+Was+Wei:UPTR-2005,
  AUTHOR = {Daniel S. Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Poly{AML}: A Polymorphic Aspect-oriented Functional Programming Language (Extended Version)},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall,
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2005,
  NUMBER = {MS-CIS-05-07},
  PLCLUB = {yes},
  MONTH = {May},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-07.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-07.pdf</a>},
  ABSTRACT = {
This paper defines PolyAML, a typed functional, aspect-oriented
programming language.  The main contribution of PolyAML is the
seamless integration of polymorphism, run-time type analysis and
aspect-oriented programming language features.  In particular, PolyAML
allows programmers to define type-safe polymorphic advice using pointcuts
constructed from a collection of polymorphic join points.  PolyAML
also comes equipped with a type inference algorithm that conservatively
extends Hindley-Milner type inference.  To support first-class
polymorphic point-cut designators, a crucial feature for developing
aspect-oriented profiling or logging libraries, the algorithm blends the
conventional Hindley-Milner type inference algorithm with a simple form
of local type inference.

We give our language operational meaning via a type-directed translation
into an expressive type-safe intermediate language.  Many complexities
of the source language are eliminated in this translation, leading
to a modular specification of its semantics.  One of the novelties
of the intermediate language is the definition of polymorphic labels
for marking control-flow points.  These labels are organized in a tree
structure such that a parent in the tree serves as a representative for
all of its children.  Type safety requires that the type
of each child is less polymorphic than its parent type.  Similarly,
when a set of labels is assembled as a pointcut, the type of each label
is an instance of the type of the pointcut.

  }
}
</pre>
</p>
<p><a name="Jon+Was+Wei:2004"></a><pre>
@MISC{Jon+Was+Wei:2004,
  AUTHOR = {Simon Peyton Jones and Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Wobbly types: type inference for generalised algebraic data types},
  YEAR = 2004,
  MONTH = {July},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/gadt.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/gadt.pdf</a>},
  PLCLUB = {yes},
  NOTE = {Unpublished},
  ABSTRACT = {
Generalised algebraic data types (GADTs), sometimes known as ``guarded
recursive data types'' or ``first-class phantom types'', are a simple
but powerful generalisation of the data types of Haskell and ML.
Recent works have given compelling examples of the utility of GADTs,
although type inference is known to be difficult.

It is time to pluck the fruit.  Can GADTs be added to Haskell, without
losing type inference, or requiring unacceptably heavy type annotations?
Can this be done without completely rewriting the already-complex Haskell
type-inference engine, and without complex interactions with (say)
type classes?  We answer these questions in the affirmative, giving
a type system that explains just what type annotations are required,
and a prototype implementation that implements it.  Our main technical
innovation is \emph{wobbly types}, which express in a declarative way
the uncertainty caused by the incremental nature of typical type-inference
algorithms.      
  }
}
</pre>
</p>
<p><a name="Was+Wei:ICFP-2003a"></a><pre>
@INPROCEEDINGS{Was+Wei:ICFP-2003a,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Boxes Go Bananas: Encoding higher-order abstract syntax with 
           parametric polymorphism},
  BOOKTITLE = {Proceedings of the Eighth {ACM SIGPLAN} International 
               Conference on Functional Programming},
  YEAR = 2003,
  MONTH = {August},
  ADDRESS = {Uppsala, Sweden},
  ORGANIZATION = {ACM SIGPLAN},
  PAGES = {249--262},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/ifcp2004-corrected.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/ifcp2004-corrected.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
Higher-order abstract syntax is a simple technique for implementing
languages with functional programming.  Object variables and binders
are implemented by variables and binders in the host language.  By
using this technique, one can avoid implementing common and tricky
routines dealing with variables, such as capture-avoiding
substitution.  However, despite the advantages this technique
provides, it is not commonly used because it is difficult to write
sound elimination forms (such as folds or catamorphisms) for
higher-order abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.

In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals.  From
this implementation, we derive ``fusion laws'' that functional
programmers may use to reason about the iteration operator.  Finally,
we show how this use of parametric polymorphism corresponds to the
Sch\"{u}rmann, Despeyroux and Pfenning method of enforcing
parametricity through modal types. We do so by using this library to
give a sound and complete encoding of their calculus into System
$\mathrm{F}_{\omega}$.  This encoding can serve as a starting point
for reasoning about higher-order structures in polymorphic languages.},
  NOTE = {
This version fixes a number of typographical errors found in the ICFP 2003     
document; there are no signficant technical changes.  Generated September 2003.}
}
</pre>
</p>
<p><a name="Was+Wei:ICFP-2003"></a><pre>
@INPROCEEDINGS{Was+Wei:ICFP-2003,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Boxes Go Bananas: Encoding higher-order abstract syntax with 
           parametric polymorphism},
  BOOKTITLE = {Proceedings of the Eighth {ACM SIGPLAN} International 
               Conference on Functional Programming},
  YEAR = 2003,
  MONTH = {August},
  ADDRESS = {Uppsala, Sweden},
  ORGANIZATION = {ACM SIGPLAN},
  PAGES = {249--262},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/icfp2003.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/icfp2003.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
Higher-order abstract syntax is a simple technique for implementing
languages with functional programming.  Object variables and binders
are implemented by variables and binders in the host language.  By
using this technique, one can avoid implementing common and tricky
routines dealing with variables, such as capture-avoiding
substitution.  However, despite the advantages this technique
provides, it is not commonly used because it is difficult to write
sound elimination forms (such as folds or catamorphisms) for
higher-order abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.

In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals.  From
this implementation, we derive ``fusion laws'' that functional
programmers may use to reason about the iteration operator.  Finally,
we show how this use of parametric polymorphism corresponds to the
Sch\"{u}rmann, Despeyroux and Pfenning method of enforcing
parametricity through modal types. We do so by using this library to
give a sound and complete encoding of their calculus into System
$\mathrm{F}_{\omega}$.  This encoding can serve as a starting point
for reasoning about higher-order structures in polymorphic languages.}
}
</pre>
</p>
<p><a name="{Dan+Wal+Was+Wei:2005"></a><pre>
@INPROCEEDINGS{{Dan+Wal+Was+Wei:2005,
  AUTHOR = {Daniel S. Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Poly{AML}: A Polymorphic Aspect-oriented Functional Programming Language},
  BOOKTITLE = {Proceedings of the Tenth {ACM SIGPLAN} International
               Conference on Functional Programming},
  YEAR = 2005,
  MONTH = {September},
  ADDRESS = {Tallinn, Estonia},
  ORGANIZATION = {ACM SIGPLAN},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/icfp2005.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/icfp2005.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
This paper defines PolyAML, a typed functional, aspect-oriented
programming language.  The main contribution of PolyAML is the
seamless integration of polymorphism, run-time type analysis and
aspect-oriented programming language features.  In particular, PolyAML
allows programmers to define type-safe polymorphic advice using pointcuts
constructed from a collection of polymorphic join points.  PolyAML
also comes equipped with a type inference algorithm that conservatively
extends Hindley-Milner type inference.  To support first-class
polymorphic point-cut designators, a crucial feature for developing
aspect-oriented profiling or logging libraries, the algorithm blends the
conventional Hindley-Milner type inference algorithm with a simple form
of local type inference.

We give our language operational meaning via a type-directed translation
into an expressive type-safe intermediate language.  Many complexities
of the source language are eliminated in this translation, leading
to a modular specification of its semantics.  One of the novelties
of the intermediate language is the definition of polymorphic labels
for marking control-flow points.  These labels are organized in a tree
structure such that a parent in the tree serves as a representative for
all of its children.  Type safety requires that the type
of each child is less polymorphic than its parent type.  Similarly,
when a set of labels is assembled as a pointcut, the type of each label
is an instance of the type of the pointcut.
  }
}
</pre>
</p>
<p><a name="Was+Wei:2005"></a><pre>
@INPROCEEDINGS{Was+Wei:2005,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Generalizing Parametricity Using Information Flow},
  BOOKTITLE = {The Twentieth Annual IEEE Symposium on Logic in Computer Science (LICS 2005)},
  YEAR = 2005,
  MONTH = {June},
  PAGES = {62--71},
  ADDRESS = {Chicago, IL},
  ORGANIZATION = {IEEE Computer Society},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/lics2005.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/lics2005.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
Run-time type analysis allows programmers to easily and concisely define
operations based upon type structure, such as serialization, iterators,
and structural equality.  However, when types can be inspected at run
time, nothing is secret.  A module writer cannot use type abstraction
to hide implementation details from clients: clients can determine the
structure of these supposedly ``abstract'' data types.  Furthermore,
access control mechanisms do not help isolate the implementation of
abstract datatypes from their clients.  Buggy or malicious authorized
modules may leak type information to unauthorized clients, so module
implementors cannot reliably tell which parts of a program rely on their
type definitions.

Currently, module implementors rely on parametric polymorphism to provide
integrity and confidentiality guarantees about their abstract datatypes.
However, standard parametricity does not hold for languages with run-time
type analysis; this paper shows how to generalize parametricity so
that it does.   The key is to augment the type system with annotations
about information-flow.  Implementors can then easily see which parts
of a program depend on the chosen implementation by tracking the flow
of dynamic type information.
  }
}
</pre>
</p>
<p><a name="POPLmark:2005"></a><pre>
@INPROCEEDINGS{POPLmark:2005,
  AUTHOR = {Brian E. Aydemir and Aaron Bohannon and Matthew Fairbairn and 
            J. Nathan Foster and Benjamin C. Pierce and Peter Sewell and
            Dimitrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich
            and Steve Zdancewic},
  TITLE = {Mechanized metatheory for the masses: The POPLmark Challenge},
  BOOKTITLE = {The Eighteenth International Conference on Theorem Proving in Higher Order Logics (TPHOLs 2005)},
  YEAR = 2005,
  MONTH = {August},
  ADDRESS = {Oxford, England},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/poplmark.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/poplmark.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
How close are we to a world where every paper on programming languages is
accompanied by an electronic appendix with machine-checked proofs?

We propose an initial set of benchmarks for measuring progress in this
area.  Based on the metatheory of System F_{<:}, a typed lambda-calculus
with second-order polymorphism, subtyping, and records, these benchmarks
embody many aspects of programming languages that are challenging to
formalize: variable binding at both the term and type levels, syntactic
forms with variable numbers of components (including binders), and
proofs demanding complex induction principles.
We hope that these benchmarks will help clarify the current state of the
art, provide a basis for comparing competing technologies, and motivate
further research.            
  }
}
</pre>
</p>
<p><a name="Vyt+Was+Wei:TLDI-2005"></a><pre>
@INPROCEEDINGS{Vyt+Was+Wei:TLDI-2005,
  AUTHOR = { Dimitrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich },
  TITLE = { An Open and Shut Typecase },
  BOOKTITLE = { The Second {ACM SIGPLAN} Workshop on Types in Language Design and Implementation },
  YEAR = 2005,
  MONTH = {January},
  ADDRESS = {Longbeach, California},
  PAGES = {13--24},
  ORGANIZATION = {ACM SIGPLAN},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/tldi2005.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/tldi2005.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
Two different ways of defining ad-hoc polymorphic operations commonly occur in
programming languages. With the first form polymorphic operations are defined
inductively on the structure of types while with the second form polymorphic
operations are defined for specific sets of types.

In intensional type analysis operations are defined by induction on the
structure of types. Therefore no new cases are necessary for user-defined types,
because these types are equivalent to their underlying structure.
However, intensional type analysis is ``closed'' to extension, as the behavior
of the operations cannot be differentiated for the new types, thus destroying
the distinctions that these types are designed to express.

Haskell type classes on the other hand define polymorphic operations for sets
of types. Operations defined by class instances are considered ``open''---the
programmer can add instances for new types without modifying existing code. However,
the operations must be extended with specialized code for each new type, and it
may be tedious or even impossible to add extensions that apply to a large
universe of new types.

Both approaches have their benefits, so it is important to let
programmers decide which is most appropriate for their needs. In this
paper, we define a language that supports both forms of ad-hoc
polymorphism, using the same basic constructs.
}
}
</pre>
</p>
<p><a name="Dan+Wal+Was+Wei:PTR-2004"></a><pre>
@TECHREPORT{Dan+Wal+Was+Wei:PTR-2004,
  AUTHOR = {Daniel S. Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Analyzing polymorphic advice},
  INSTITUTION = {Princeton University},
  ADDRESS = {Department of Computer Science, Princeton University, 
             35 Olden Street, Princeton, NJ 08544 },
  YEAR = 2004,
  NUMBER = {TR-717-04},
  MONTH = {December},
  PDF = {<a href="http://www.cis.upenn.edu/~geoffw/research/papers/tr-717-04.pdf">http://www.cis.upenn.edu/~geoffw/research/papers/tr-717-04.pdf</a>},
  PLCLUB = {yes},
  ABSTRACT = {
We take one of the first steps towards developing a practical,
statically-typed, functional, aspect-oriented programming language
by showing how to integrate polymorphism and type analysis with
aspect-oriented programming features.  In particular, we demonstrate
how to define type-safe polymorphic advice using pointcuts that unify
a collection of polymorphic join points.  We also introduce a new
mechanism for specifying context-sensitive advice that involves pattern
matching against the current stack of activation records, and meshes
well with functional programming idioms.  We give our language meaning
via a type-directed translation into an expressive, but fairly simple,
type-safe intermediate language.  Many complexities of the source language
are eliminated in this translation, leading to a modular specification
of its semantics.  One of the novelties of the intermediate language is
the definition of polymorphic labels for marking control-flow points.
These labels are organized in a tree structure such that a parent in the
tree serves as a representative for the collection of all its children.
Type safety requires that the type of each child is a generic instance
of the type of the polymorphic parent.  Similarly, when a set of labels
is assembled as a pointcut, the type of each label is an instance of
the type of the pointcut.
  }
}
</pre>
</p>
<p><a name="looj04"></a><pre>
@INPROCEEDINGS{looj04,
  AUTHOR = {Kim B. Bruce and J. Nathan Foster},
  TITLE = {{LOOJ}: Weaving {LOOM} into {J}ava},
  BOOKTITLE = {European Conference on Object-Oriented Programming (ECOOP), Oslo, Norway},
  PAGES = {389-413},
  YEAR = {2004},
  MONTH = JUN,
  VOLUME = {3086},
  SERIES = {Lecture Notes in Computer Science},
  PUBLISHER = {Springer-Verlag},
  CONF = {<a href="http://www.cis.upenn.edu/~jnfoster/papers/looj.pdf">http://www.cis.upenn.edu/~jnfoster/papers/looj.pdf</a>},
  SLIDES = {<a href="http://www.cis.upenn.edu/~jnfoster/papers/looj-slides.pdf">http://www.cis.upenn.edu/~jnfoster/papers/looj-slides.pdf</a>},
  ABSTRACT = {LOOJ is an extension of Java obtained by adding bounded
              parametric polymorphism and new type expressions
              ThisClass and ThisType, which are similar to MyType in
              LOOM. Through examples we demonstrate the utility of
              this language even over very expressive extensions such
              as GJ. The LOOJ compiler generates standard JVML code
              and supports instanceof and casts for all types
              including type variables and the other new type
              expressions. The core of the LOOJ type system is sound,
              as demonstrated by a soundness proof for an extension of
              Featherweight GJ. This paper also highlights
              difficulties that arise from the use of both classes and
              interfaces as types in Java.},
  PLCLUB = {Yes},
  JNF = {Yes}
}
</pre>
</p>
<p><a name="vytiniotis+:boxy"></a><pre>
@UNPUBLISHED{vytiniotis+:boxy,
  AUTHOR = {Dimitrios Vytiniotis and Stephanie Weirich and Simon {Peyton Jones}},
  TITLE = {Boxy type inference for higher-rank types and impredicativity},
  NOTE = {Submitted for publication},
  MONTH = APR,
  YEAR = 2005,
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/boxy/boxy.ps">http://www.cis.upenn.edu/~sweirich/papers/boxy/boxy.ps</a>},
  PLCLUB = {yes},
  ABSTRACT = {
Languages with rich type systems are beginning to employ a blend of type
inference and type checking, so that the type inference engine is
guided by programmer-supplied type annotations.  In this paper we show,
for the first time, how to combine the virtues of two well-established ideas: unification-based 
inference, and bidirectional propagation of type annotations.  The result 
is a type system that conservatively extends Hindley-Milner, and yet supports
both higher-rank and impredicative types.
}
}
</pre>
</p>
<p><a name="weirich+:tdj"></a><pre>
@INPROCEEDINGS{weirich+:tdj,
  PLCLUB = {yes},
  AUTHOR = {Stephanie Weirich and Liang Huang},
  TITLE = {A Design for Type-Directed {Java}},
  BOOKTITLE = {Workshop on Object-Oriented Developments},
  YEAR = 2004,
  EDITOR = {Viviana Bono},
  SERIES = {ENTCS},
  NOTE = {20 pages. An extended version (49 pages) of this paper is 
                  University of Pennsylvania 
                  Computer and Information Science Technical Report 
                  MS-CIS-04-11.},
  PS = {<a href="http://www.cis.upenn.edu/%7Elhuang3/pubs/tdj-short.ps">http://www.cis.upenn.edu/%7Elhuang3/pubs/tdj-short.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/%7Elhuang3/pubs/tdj-short.pdf">http://www.cis.upenn.edu/%7Elhuang3/pubs/tdj-short.pdf</a>},
  ABSTRACT = {   
  Type-directed programming is an important and widely used
  paradigm in the design of software. With this form of programming,
  an application may analyze type information to determine its
  behavior. By analyzing the structure of data, many operations, such
  as serialization, cloning, adaptors and iterators may be defined
  once, for all types of data. That way, as the program evolves, these
  operations need not be updated---they will automatically adapt to
  new data forms.  Otherwise, each of these operations must be
  individually redefined for each type of data, forcing programmers to
  revisit the same program logic many times during a program's
  lifetime.

  The Java language supports type directed programming with the
  instanceof operator and the Java Reflection API.  These
  mechanisms allow Java programs to depend on the name and structure
  of the run-time classes of objects.  However, the Java mechanisms
  for type-directed programming are difficult to use. They also do not
  integrate well with generics, an important new feature of the Java
  language.

  In this paper, we describe the design of several expressive new
  mechanisms for type-directed programming in Java, and show that
  these mechanisms are sound when included in a language similar to
  Featherweight Java. Basically, these new mechanisms pattern-match
  the name and structure of the type parameters of generic code,
  instead of the run-time classes of objects.  Therefore, they
  naturally integrate with generics and provide strong guarantees
  about program correctness. As these mechanisms are based on pattern
  matching, they naturally and succinctly express many operations that
  depend on type information. Finally, they provide programmers with
  some degree of protection for their abstractions. Whereas
  instanceof and reflection can determine the exact run-time type
  of an object, our mechanisms allow any supertype to be supplied for
  analysis, hiding its precise structure.}
}
</pre>
</p>
<p><a name="weirich:cast-journal"></a><pre>
@ARTICLE{weirich:cast-journal,
  PLCLUB = {yes},
  AUTHOR = {Stephanie Weirich},
  TITLE = {Type-Safe Cast},
  JOURNAL = {Journal of Functional Programming},
  MONTH = NOV,
  YEAR = 2004,
  VOLUME = 14,
  NUMBER = 6,
  PAGES = {681-695},
  PDF = {<a href="http://journals.cambridge.org/bin/bladerunner?REQUNIQ=1098990699&amp;REQSESS=1422511&amp;118000REQEVENT=&amp;REQINT1=254715&amp;REQAUTH=0">http://journals.cambridge.org/bin/bladerunner?REQUNIQ=1098990699&amp;REQSESS=1422511&amp;118000REQEVENT=&amp;REQINT1=254715&amp;REQAUTH=0</a>},
  ABSTRACT = {   Comparing two types for equality is an essential ingredient for an
  implementation of dynamic types. Once equality has been established,
  it is safe to cast a value from one type to another. In a language
  with run-time type analysis, implementing such a procedure is fairly
  straightforward.  Unfortunately, this naive implementation destructs
  and rebuilds the argument while iterating over its type structure.
  However, by using higher-order polymorphism, a casting function can
  treat its argument parametrically. We demonstrate this solution in
  two frameworks for ad-hoc polymorphism: intensional type analysis
  and Haskell type classes.}
}
</pre>
</p>
<p><a name="huang+:tdp-tr"></a><pre>
@TECHREPORT{huang+:tdp-tr,
  PLCLUB = {yes},
  AUTHOR = {Liang Huang and Stephanie Weirich},
  TITLE = {A Design for Type-Directed Programming in {Java}
                 (Extended Version)},
  INSTITUTION = {University of Pennsylvania, Computer and Information Science},
  YEAR = 2004,
  NUMBER = {MS-CIS-04-11},
  MONTH = OCT,
  PAGES = {1--49},
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.ps">http://www.cis.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.pdf">http://www.cis.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.pdf</a>}
}
</pre>
</p>
<p><a name="weirich:phd"></a><pre>
@PHDTHESIS{weirich:phd,
  PLCLUB = {yes},
  AUTHOR = {Stephanie Weirich},
  TITLE = {Programming With Types},
  SCHOOL = {Cornell University},
  MONTH = AUG,
  YEAR = 2002,
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/thesis/thesis.ps">http://www.cis.upenn.edu/~sweirich/papers/thesis/thesis.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~sweirich/papers/thesis/thesis.pdf">http://www.cis.upenn.edu/~sweirich/papers/thesis/thesis.pdf</a>},
  NOTE = {238 pages},
  ABSTRACT = {Run-time type analysis is an increasingly important linguistic
     mechanism in modern programming languages. Language runtime
     systems use it to implement services such as accurate garbage
     collection, serialization, cloning and structural
     equality. Component frameworks rely on it to provide reflection
     mechanisms so they may discover and interact with program
     interfaces dynamically. Run-time type analysis is also crucial
     for large, distributed systems that must be dynamically extended,
     because it allows those systems to check program invariants when
     new code and new forms of data are added. Finally, many generic
     user-level algorithms for iteration, pattern matching, and
     unification can be defined through type analysis mechanisms.

     However, existing frameworks for run-time type analysis were
     designed for simple type systems. They do not scale well to the
     sophisticated type systems of modern and next-generation
     programming languages that include complex constructs such as
     first-class abstract types, recursive types, objects, and type
     parameterization. In addition, facilities to support type
     analysis often require complicated language semantics that allow
     little freedom in their implementation.  This dissertation
     investigates the foundations of run-time type analysis in the
     context of statically-typed, polymorphic programming languages.
     Its goal is to show how such a language may support
     type-analyzing operations in a way that balances expressiveness,
     safety and simplicity.}
}
</pre>
</p>
<p><a name="weirich:hota"></a><pre>
@INPROCEEDINGS{weirich:hota,
  PLCLUB = {yes},
  AUTHOR = {Stephanie Weirich},
  TITLE = {Higher-Order Intensional Type Analysis},
  BOOKTITLE = {11th European Symposium on Programming (ESOP)},
  EDITOR = {Daniel Le M\'{e}tayer},
  PAGES = {98--114},
  YEAR = 2002,
  MONTH = APR,
  ADDRESS = {Grenoble, France},
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/hota/hota.ps">http://www.cis.upenn.edu/~sweirich/papers/hota/hota.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~sweirich/papers/hota/hota.pdf">http://www.cis.upenn.edu/~sweirich/papers/hota/hota.pdf</a>},
  ABSTRACT = {Intensional type analysis provides the ability to
     analyze abstracted types at run time. In this paper, we extend
     that ability to higher-order and kind-polymorphic type
     constructors. The resulting language is elegant and expressive:
     we show through examples how it extends the repertoire of
     polytypic functions that may be defined.}
}
</pre>
</p>
<p><a name="weirich01"></a><pre>
@INPROCEEDINGS{weirich01,
  PLCLUB = {yes},
  AUTHOR = {Stephanie Weirich},
  TITLE = {Encoding Intensional Type Analysis},
  BOOKTITLE = {10th European Symposium on Programming (ESOP)},
  YEAR = 2001,
  EDITOR = {D. Sands},
  PAGES = {92--106},
  ADDRESS = {Genova, Italy},
  MONTH = APR,
  ANNOTE = { 2001 Springer-Verlag. Minor corrections in local version.},
  URL = {<a href="http://link.springer.de/link/service/series/0558/tocs/t2028.htm">http://link.springer.de/link/service/series/0558/tocs/t2028.htm</a>},
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/depabs/depabs.ps">http://www.cis.upenn.edu/~sweirich/papers/depabs/depabs.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~sweirich/papers/depabs/depabs.pdf">http://www.cis.upenn.edu/~sweirich/papers/depabs/depabs.pdf</a>},
  ABSTRACT = {Languages for intensional type analysis permit ad-hoc
     polymorphism, or run-time analysis of types. However, such
     languages require complex, specialized constructs to support this
     operation, which hinder optimization and complicate the
     meta-theory of these languages. In this paper, we observe that
     such specialized operators need not be intrinsic to the language,
     and in fact, their operation may be simulated through standard
     encodings of iteration in the polymorphic lambda
     calculus. Therefore, we may more easily add intensional analysis
     operators to complicated languages via a translation semantics,
     instead of through language extension.}
}
</pre>
</p>
<p><a name="weirich00"></a><pre>
@INPROCEEDINGS{weirich00,
  PLCLUB = {yes},
  AUTHOR = {Stephanie Weirich},
  TITLE = {Type-Safe Cast: Functional Pearl},
  BOOKTITLE = {Proceedings of theFifth {ACM} {SIGPLAN} {I}nternational {C}onference on {F}unctional {P}rogramming
                    ({ICFP})},
  YEAR = 2000,
  MONTH = SEP,
  ADDRESS = {Montreal, Canada},
  PAGES = {58--67},
  ABSTRACT = {In a language with non-parametric or ad-hoc
    polymorphism, it is possible to determine the identity of a type
    variable at run time.  With this facility, we can write a function
    to convert a term from one abstract type to another, if the two
    hidden types are identical.  However, the naive implementation of
    this function requires that the term be destructed and rebuilt. In
    this paper, we show how to eliminate this overhead using
    higher-order type abstraction. We demonstrate this solution in two
    frameworks for ad-hoc polymorphism: intensional type analysis and
    type classes.},
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/cast/cast.ps">http://www.cis.upenn.edu/~sweirich/papers/cast/cast.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~sweirich/papers/cast/cast.pdf">http://www.cis.upenn.edu/~sweirich/papers/cast/cast.pdf</a>}
}
</pre>
</p>
<p><a name="crary00"></a><pre>
@INPROCEEDINGS{crary00,
  PLCLUB = {yes},
  AUTHOR = {Karl Crary and Stephanie Weirich},
  TITLE = {Resource Bound Certification},
  BOOKTITLE = {Twenty-Seventh  {ACM} {SIGPLAN--SIGACT} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL})},
  PAGES = {184--198},
  YEAR = 2000,
  ADDRESS = {Boston, MA, USA},
  MONTH = JAN,
  PDF = {<a href="http://www.cis.upenn.edu/~sweirich/papers/res/res.pdf">http://www.cis.upenn.edu/~sweirich/papers/res/res.pdf</a>},
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/res/res.ps.gz">http://www.cis.upenn.edu/~sweirich/papers/res/res.ps.gz</a>},
  ABSTRACT = {Various code certification systems allow the
    certification and static verification of a variety of important
    safety properties such as memory safety and control-flow
    safety. These systems provide valuable tools for verifying that
    untrusted and potentially malicious code is safe before execution.
    However, one important safety property that is not usually
    included is that programs adhere to specific bounds on resource
    consumption, such as running time.

    We present a decidable type system capable of specifying and
    certifying bounds on resource consumption. Our system makes two
    advances over previous resource bound certification systems, both
    of which are necessary for a practical system: we allow the
    execution time of programs and their subroutines to vary,
    depending on their arguments, and we provide a fully automatic
    compiler generating certified executables from source-level
    programs. The principal device in our approach is a strategy for
    simulating dependent types using sum and inductive kinds. }
}
</pre>
</p>
<p><a name="morrisett+:talx86"></a><pre>
@INPROCEEDINGS{morrisett+:talx86,
  PLCLUB = {yes},
  AUTHOR = {Greg Morrisett and Karl Crary and Neal Glew and Dan
                  Grossman and Richard Samuels and Frederick Smith and
                  David Walker and Stephanie Weirich and Steve
                  Zdancewic},
  TITLE = {{TALx86}: A Realistic Typed Assembly Language},
  BOOKTITLE = {Second  {ACM}{SIGPLAN} Workshop on Compiler Support for System Software},
  YEAR = 1999,
  MONTH = MAY,
  PAGES = {25--35},
  NOTE = {Published as {INRIA} research report number 0228, March 1999.},
  ADDRESS = {Atlanta, GA, USA},
  PS = {<a href="http://www.cs.cornell.edu/talc/papers/talx86-wcsss.ps.gz">http://www.cs.cornell.edu/talc/papers/talx86-wcsss.ps.gz</a>},
  ABSTRACT = {The goal of typed assembly language (TAL) is to provide
     a low-level, statically typed target language that is better
     suited than Java bytecodes for supporting a wide variety of
     source languages and a number of important optimizations. In
     previous work, we formalized idealized versions of TAL and proved
     important safety properties about them. In this paper, we present
     our progress in defining and implementing a realistic typed
     assembly language called TALx86. The TALx86 instructions comprise
     a relatively complete fragment of the Intel IA32 (32-bit 80x86
     flat model) assembly language and are thus executable on
     processors such as the Intel Pentium. The type system for the
     language incorporates a number of advanced features necessary for
     safely compiling large programs to good code.

     To motivate the design of the type system, we demonstrate how
     various high-level language features are compiled to TALx86. For
     this purpose, we present a type-safe C-like language called
     Popcorn.}
}
</pre>
</p>
<p><a name="crary+:lx"></a><pre>
@INPROCEEDINGS{crary+:lx,
  PLCLUB = {yes},
  AUTHOR = {Karl Crary and Stephanie Weirich},
  TITLE = {Flexible Type Analysis},
  BOOKTITLE = {Proceedings of theFourth {ACM} {SIGPLAN} {I}nternational {C}onference on {F}unctional {P}rogramming
                    ({ICFP})},
  YEAR = 1999,
  MONTH = SEP,
  ADDRESS = {Paris, France},
  PAGES = {233--248},
  ABSTRACT = {Run-time type dispatch enables a variety of advanced
     optimization techniques for polymorphic languages, including
     tag-free garbage collection, unboxed function arguments, and
     flattened data structures.  However, modern type-preserving
     compilers transform types between stages of compilation, making
     type dispatch prohibitively complex at low levels of typed
     compilation. It is crucial therefore for type analysis at these
     low levels to refer to the types of previous
     stages. Unfortunately, no current intermediate language supports
     this facility.

     To fill this gap, we present the language LX, which provides a
     rich language of type constructors supporting type analysis
     (possibly of previous-stage types) as a programming idiom. This
     language is quite flexible, supporting a variety of other
     applications such as analysis of quantified types, analysis with
     incomplete type information, and type classes. We also show that
     LX is compatible with a type-erasure semantics.},
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/lx/lxpaper.ps.gz">http://www.cis.upenn.edu/~sweirich/papers/lx/lxpaper.ps.gz</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~sweirich/papers/lx/lxpaper.pdf">http://www.cis.upenn.edu/~sweirich/papers/lx/lxpaper.pdf</a>}
}
</pre>
</p>
<p><a name="crary+:intensional"></a><pre>
@INPROCEEDINGS{crary+:intensional,
  PLCLUB = {yes},
  AUTHOR = {Karl Crary and Stephanie Weirich and Greg Morrisett},
  TITLE = {Intensional Polymorphism in Type Erasure Semantics},
  BOOKTITLE = {Proceedings of theThird {ACM} {SIGPLAN} {I}nternational {C}onference on {F}unctional {P}rogramming
                    ({ICFP})},
  YEAR = 1998,
  ADDRESS = {Baltimore, MD, USA},
  MONTH = SEP,
  PAGES = {301--313},
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/typepass/typepass.ps">http://www.cis.upenn.edu/~sweirich/papers/typepass/typepass.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~sweirich/papers/typepass/typepass.pdf">http://www.cis.upenn.edu/~sweirich/papers/typepass/typepass.pdf</a>},
  ABSTRACT = { Intensional polymorphism, the ability to dispatch to
  different routines based on types at run time, enables a variety of
  advanced implementation techniques for polymorphic languages,
  including tag-free garbage collection, unboxed function arguments,
  polymorphic marshalling, and flattened data structures. To date,
  languages that support intensional polymorphism have required a
  type-passing (as opposed to type-erasure) interpretation where types
  are constructed and passed to polymorphic functions at run
  time. Unfortunately, type-passing suffers from a number of
  drawbacks; it requires duplication of constructs at the term and
  type levels, it prevents abstraction, and it severely complicates
  polymorphic closure conversion. We present a type-theoretic
  framework that supports intensional polymorphism, but avoids many of
  the disadvantages of type passing. In our approach, run-time type
  information is represented by ordinary terms. This avoids the
  duplication problem, allows us to recover abstraction, and avoids
  complications with closure conversion. In addition, our type system
  provides another improvement in expressiveness; it allows unknown
  types to be refined in place thereby avoiding certain
  beta-expansions required by other frameworks.  }
}
</pre>
</p>
<p><a name="HicksW00type-loading-tr"></a><pre>
@TECHREPORT{HicksW00type-loading-tr,
  PLCLUB = {yes},
  AUTHOR = {Michael Hicks and Stephanie Weirich},
  TITLE = {A Calculus for Dynamic Loading},
  INSTITUTION = {University of Pennsylvania},
  YEAR = {2000},
  NUMBER = {MS-CIS-00-07},
  MONTH = {April},
  PDF = { http://www.cis.upenn.edu/~mwh/papers/loadcalc.pdf }
}
</pre>
</p>
<p><a name="hicks00"></a><pre>
@INCOLLECTION{hicks00,
  PLCLUB = {yes},
  AUTHOR = {Michael Hicks and Stephanie Weirich and Karl Crary},
  TITLE = {Safe and Flexible Dynamic Linking of Native Code},
  BOOKTITLE = {Types in Compilation: Third International Workshop, TIC 2000;
               Montreal, Canada, September 21, 2000; Revised Selected Papers},
  EDITOR = {R. Harper},
  PUBLISHER = {Springer},
  YEAR = 2001,
  SERIES = {Lecture Notes in Computer Science},
  VOLUME = 2071,
  PAGES = {147--176},
  NOTE = {Related technical report: Michael Hicks and Stephanie
     Weirich.  A calculus for dynamic loading. 
    University of Pennsylvania Computer and Information Science
     Technical Report,
     MS-CIS-00-07,  April 2000.},
  ABSTRACT = {We present the design and implementation of the first
     complete framework for flexible and safe dynamic linking of
     native code. Our approach extends Typed Assembly Language with a
     primitive for loading and typechecking code, which is flexible
     enough to support a variety of linking strategies, but simple
     enough that it does not significantly expand the trusted
     computing base. Using this primitive, along with the ability to
     compute with types, we show that we can program many existing
     dynamic linking approaches. As a concrete demonstration, we have
     used our framework to implement dynamic linking for a type-safe
     dialect of C, closely modeled after the standard linking facility
     for Unix C programs. Aside from the unavoidable cost of
     verification, our implementation performs comparably with the
     standard, untyped approach.},
  URL = {<a href="http://link.springer.de/link/service/series/0558/tocs/t2071.htm">http://link.springer.de/link/service/series/0558/tocs/t2071.htm</a>},
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/taldynlink/taldynlink.ps.gz">http://www.cis.upenn.edu/~sweirich/papers/taldynlink/taldynlink.ps.gz</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~sweirich/papers/taldynlink/taldynlink.pdf">http://www.cis.upenn.edu/~sweirich/papers/taldynlink/taldynlink.pdf</a>}
}
</pre>
</p>
<p><a name="flanagan96"></a><pre>
@INPROCEEDINGS{flanagan96,
  PLCLUB = {yes},
  AUTHOR = {Cormac Flanagan and Matthew Flatt and Shriram
             Krishnamurthi and Stephanie Weirich and Matthias
             Felleisen},
  TITLE = {Catching Bugs in the Web of Program Invariants},
  BOOKTITLE = {Proceedings of the{ACM SIGPLAN Conference on Programming Language Design
                    and Implementation (PLDI)}},
  YEAR = 1996,
  PAGES = {23--32},
  ABSTRACT = {MrSpidey is a user-friendly, interactive static
     debugger for Scheme. A static debugger supplements the standard
     debugger by analyzing the program and pinpointing those program
     operations tha may cause run-time errors suce as dereferencing
     the null pointer or applying non-functions. The program analysis
     of MrSpidey computes value set descriptions for each term in the
     program and constructs a value flow graph connecting the set
     descriptions. Using the set descriptions, MrSpidey can identify
     and highlight potentially erroneous program operations, whose
     cause the programmer can the explore by selectively exposing
     portions of the value flow graph.},
  PS = {<a href="http://www.cis.upenn.edu/~sweirich/papers/pldi96-ffkwf_ps.gz">http://www.cis.upenn.edu/~sweirich/papers/pldi96-ffkwf_ps.gz</a>}
}
</pre>
</p>
<pre>
@COMMENT{{{{This file has been generated by bib2bib 1.75}}
</pre>

<pre>
@COMMENT{{{{Command line: /usr/bin/bib2bib -ob zdancewic.bib-tmp -c 'not($key = "ABFF+05")' zdancewic.bib}}
</pre>

<p><a name="HTHZ05"></a><pre>
@INPROCEEDINGS{HTHZ05,
  AUTHOR = {Michael Hicks and Stephen Tse and Boniface Hicks 
                  and Steve Zdancewic},
  TITLE = {Dynamic updating of information-flow policies},
  BOOKTITLE = {Proc. of Foundations of Computer Security Workshop},
  YEAR = 2005,
  HCONF = {yes},
  PLCLUB = {yes},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/HTHZ05.pdf">http://www.cis.upenn.edu/~stevez/papers/HTHZ05.pdf</a>},
  ABSTRACT = { Applications that manipulate sensitive information
  should ensure \emph{end-to-end} security by satisfying two
  properties: \emph{sound execution} and some form of
  \emph{noninterference}.  By the former, we mean the program should
  always perform actions in keeping with its current policy, and by
  the latter we mean that these actions should never cause
  high-security information to be visible to a low-security observer.
  Over the last decade, security-typed languages have been developed
  that exhibit these properties, increasingly improving so as to model
  important features of real programs.

  No current security-typed language, however, permits general changes
  to security policies in use by running programs.  This paper
  presents a simple information flow type system for that allows for
  dynamic security policy updates while ensuring sound execution and a
  relaxed form of noninterference we term \emph{noninterference
  between updates}.  We see this work as an important step toward
  using language-based techniques to ensure end-to-end security for
  realistic applications.}
}
</pre>
</p>
<p><a name="LZ05c"></a><pre>
@INPROCEEDINGS{LZ05c,
  AUTHOR = {Peng Li and Steve Zdancewic},
  TITLE = {{Unifying Confidentiality and Integrity in Downgrading 
                  Policies}},
  BOOKTITLE = {Proc. of Foundations of Computer Security Workshop},
  YEAR = 2005,
  HCONF = {yes},
  PLCLUB = {yes},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ05c.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ05c.pdf</a>},
  ABSTRACT = {Confidentiality and integrity are often treated as dual
  properties in formal models of information-flow control, access
  control and many other areas in computer security. However, in
  contrast to confidentiality policies, integrity policies are less
  formally studied in the information-flow control literature. One
  important reason is that traditional noninterference-based
  information-flow control approaches give very weak integrity
  guarantees for untrusted code. Integrity and confidentiality
  policies are also different with respect to implicit information
  channels. 

  This paper studies integrity downgrading policies in
  information-flow control and compares them with their
  confidentiality counterparts. We examine the drawbacks of integrity
  policies based on noninterference formalizations and study the
  integrity policies in the framework of downgrading policies and
  program equivalences. We give semantic interpretations for
  traditional security levels for integrity, namely, tainted and
  untainted, and explain the interesting relations between
  confidentiality and integrity in this framework.  }
}
</pre>
</p>
<p><a name="Zda04"></a><pre>
@INPROCEEDINGS{Zda04,
  AUTHOR = {Steve Zdancewic},
  TITLE = {{Challenges for Information-flow Security}},
  BOOKTITLE = {Proceedings of the 1st International Workshop on the
  Programming Language Interference and Dependence (PLID'04)},
  YEAR = 2004,
  HINVITED = {yes},
  PLCLUB = {yes},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/Zda04.pdf">http://www.cis.upenn.edu/~stevez/papers/Zda04.pdf</a>}
}
</pre>
</p>
<p><a name="Zda03"></a><pre>
@INPROCEEDINGS{Zda03,
  AUTHOR = {Steve Zdancewic},
  TITLE = {{A Type System for Robust Declassification}},
  BOOKTITLE = {Proceedings of the Nineteenth Conference on the 
                  Mathematical Foundations of Programming Semantics},
  YEAR = 2003,
  MONTH = MAR,
  PUBLISHER = {Electronic Notes in Theoretical Computer Science},
  HINVITED = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/Zda03.ps">http://www.cis.upenn.edu/~stevez/papers/Zda03.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/Zda03.pdf">http://www.cis.upenn.edu/~stevez/papers/Zda03.pdf</a>},
  ABSTRACT = {Language-based approaches to information security have led to the
  development of \emph{security type systems\/} that permit the
  programmer to describe confidentiality policies on data.  Security
  type systems are usually intended to enforce \emph{noninterference},
  a property that requires that high-security information not affect
  low-security computation.  However, in practice, noninterference is
  often too restrictive---the desired policy does permit some
  information leakage.

  
  To compensate for the strictness of noninterference, practical
  approaches include some mechanism for \emph{declassifying}
  high-security information.  But such declassification is potentially
  dangerous, and its use should be restricted to prevent unintended
  information leaks. Zdancewic and Myers previously introduced the
  notion of \emph{robust declassification\/} in an attempt to capture
  the desired restrictions on declassification, but that work did not
  propose a method for determining when a program satisfies the 
  robust declassification condition.


  This paper motivates robust declassification and shows that a simple
  change to a security type system can enforce it.  The idea is to
  extend the lattice of security labels to include \emph{integrity}
  constraints as well as confidentiality constraints and then require
  that the decision to perform a declassification have high
  integrity.}
}
</pre>
</p>
<p><a name="ZM02"></a><pre>
@ARTICLE{ZM02,
  AUTHOR = {Steve Zdancewic and Andrew C. Myers},
  TITLE = {{Secure Information Flow via Linear Continuations}},
  JOURNAL = {Higher Order and Symbolic Computation},
  VOLUME = 15,
  NUMBER = {2/3},
  YEAR = 2002,
  HJOURNAL = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM02.ps">http://www.cis.upenn.edu/~stevez/papers/ZM02.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM02.pdf">http://www.cis.upenn.edu/~stevez/papers/ZM02.pdf</a>},
  ABSTRACT = {\emph{Security-typed languages} enforce secrecy or integrity policies by
type-checking.  This paper investigates continuation-passing style (CPS) as a
means of proving that such languages enforce noninterference and as a first
step towards understanding their compilation.  We present a low-level, secure
calculus with higher-order, imperative features and \emph{linear
continuations}.


Linear continuations impose a stack discipline on the control flow of
programs.  This additional structure in the type system lets us establish a
strong information-flow security property called \emph{noninterference}.  We prove
that our CPS target language enjoys the noninterference property and we show
how to translate secure high-level programs to this low-level
language.  This noninterference proof is the first of its kind for a
language with higher-order functions and state.}
}
</pre>
</p>
<p><a name="ZZNM02"></a><pre>
@ARTICLE{ZZNM02,
  AUTHOR = {Steve Zdancewic and Lantian Zheng and Nathaniel Nystrom
		  and Andrew C. Myers},
  TITLE = {{Secure Program Partitioning}},
  JOURNAL = {Transactions on Computer Systems},
  YEAR = 2002,
  VOLUME = 20,
  NUMBER = 3,
  PAGES = {283--328},
  HJOURNAL = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM02.ps">http://www.cis.upenn.edu/~stevez/papers/ZZNM02.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM02.pdf">http://www.cis.upenn.edu/~stevez/papers/ZZNM02.pdf</a>},
  ABSTRACT = {This paper presents secure program partitioning, a language-based
technique for protecting confidential data during computation in
distributed systems containing mutually untrusted hosts. Confidentiality
and integrity policies can be expressed by annotating programs with
security types that constrain information flow; these programs can then
be partitioned automatically to run securely on heterogeneously trusted
hosts. The resulting communicating subprograms collectively implement
the original program, yet the system as a whole satisfies the security
requirements of participating principals without requiring a universally
trusted host machine.  The experience in applying this methodology and
the performance of the resulting distributed code suggest that this is a
promising way to obtain secure distributed computation.


This article is an expanded version of the published paper ``Untrusted
Hosts and Confidentiality: Secure Program Partitioning''.
The main difference between the two is Appendix A, which
contains a correctness proof for the control-transfer protocols described
in Section 5.}
}
</pre>
</p>
<p><a name="GMZ00"></a><pre>
@ARTICLE{GMZ00,
  AUTHOR = {Dan Grossman and Greg Morrisett and Steve Zdancewic},
  TITLE = {{Syntactic Type Abstraction}},
  JOURNAL = {Transactions on Programming Languages and Systems},
  YEAR = 2000,
  VOLUME = 22,
  NUMBER = 6,
  PAGES = {1037--1080},
  MONTH = NOV,
  HJOURNAL = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/GMZ00.ps">http://www.cis.upenn.edu/~stevez/papers/GMZ00.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/GMZ00.pdf">http://www.cis.upenn.edu/~stevez/papers/GMZ00.pdf</a>},
  ABSTRACT = {Software developers often structure programs in such a
way that different pieces of code constitute distinct
principals. Types help define the protocol by which these principals
interact. In particular, abstract types allow a principal to make
strong assumptions about how well-typed clients use the facilities
that it provides. We show how the notions of principals and type
abstraction can be formalized within a language. Different principals
can know the implementation of different abstract types. We use
additional syntax to track the flow of values with abstract types
during the evaluation of a program and demonstrate how this framework
supports syntactic proofs (in the style of subject reduction) for
type-abstraction properties. Such properties have traditionally
required semantic arguments; using syntax avoids the need to build a
model for the language. We present various typed lambda calculi with
principals, including versions that have mutable state and recursive types.}
}
</pre>
</p>
<p><a name="TZ04b"></a><pre>
@INPROCEEDINGS{TZ04b,
  AUTHOR = {Stephen Tse and Steve Zdancewic},
  TITLE = {{Translating Dependency into Parametricity}},
  BOOKTITLE = {Proc. of the 9th ACM SIGPLAN International Conference on
		  Functional Programming},
  YEAR = 2004,
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ04b.ps">http://www.cis.upenn.edu/~stevez/papers/TZ04b.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ04b.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ04b.pdf</a>},
  ABSTRACT = {
  The \textit{dependency core calculus} (DCC) was introduced by Abadi
  et al. as a unifying formal framework in which to study a variety of
  important program analyses including binding-time, information-flow,
  slicing, and function call tracking. The novel feature of DCC is a
  lattice of monads and a nonstandard typing rule for their associated
  \texttt{bind} operations.  Intuitively, the lattice structure describes
  which computations in a program may depend on each other.  Abadi et
  al.  prove a \textit{noninterference} result that establishes the
  correctness of DCC's type system, and they use that result to show
  that type systems for the above-mentioned analyses are correct.
  

  In this paper, we study the relationship between DCC and the
  Girard--Reynolds polymorphic lambda calculus (System F).  In
  particular, we show how to encode the recursion-free fragment of DCC
  into F via a type-directed translation.  The main theorem we present
  uses this translation to derive the noninterference result for DCC
  from the standard parametricity theorem of System F.  In addition to
  providing insight into DCC's type system, the hope is that the
  translation presented here may yield implementation strategies for
  non-standard type systems (e.g. for information flow security) in
  languages that have parametric polymorphism.
  }
}
</pre>
</p>
<p><a name="MSZ04"></a><pre>
@INPROCEEDINGS{MSZ04,
  AUTHOR = {Andrew C. Myers and Andrei Sabelfeld and Steve Zdancewic},
  TITLE = {{Enforcing Robust Declassification}},
  BOOKTITLE = {Proc. of 17th IEEE Computer Security Foundations Workshop},
  PAGES = {172--186},
  YEAR = 2004,
  ADDRESS = {Asilomar, CA},
  MONTH = JUN,
  PUBLISHER = {{IEEE} Computer Society Press},
  HCONF = {yes},
  PLCLUB = {yes},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/MSZ04.pdf">http://www.cis.upenn.edu/~stevez/papers/MSZ04.pdf</a>},
  ABSTRACT = {
    Noninterference requires that there
  is no information flow from sensitive to public data in a given
  system. However, many systems perform
  intentional release of sensitive information as part of their
  correct functioning and therefore violate noninterference.
  To control information flow while permitting intentional
  information release, some systems have a downgrading or
  declassification mechanism. A major danger of such a mechanism is
  that it may cause unintentional information release.
  This paper shows that a robustness property
  can be used to characterize programs in which declassification mechanisms
  cannot be exploited by attackers to release more information than
  intended. It describes a simple way to provably enforce this robustness
  property through a type-based compile-time program analysis. The paper also
  presents a generalization of robustness that
  supports upgrading (endorsing) data integrity.
  }
}
</pre>
</p>
<p><a name="TZ05a"></a><pre>
@INPROCEEDINGS{TZ05a,
  AUTHOR = {Stephen Tse and Steve Zdancewic},
  TITLE = {{Designing a Security-typed Language with Certificate-based Declassification}},
  BOOKTITLE = {Proc. of the 14th European Symposium on Programming},
  YEAR = 2005,
  NOTE = {To appear},
  HCONF = {yes},
  PLCLUB = {yes},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ05a.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ05a.pdf</a>},
  ABSTRACT = {This paper presents a calculus that supports information-flow
  security policies and certificate-based declassification. The
  decentralized label model and its downgrading mechanisms are
  concisely expressed in the polymorphic lambda calculus with
  subtyping (System F-Sub).  We prove a conditioned version of the
  noninterference theorem such that authorization for declassification
  is justified by digital certificates from public-key
  infrastructures.}
}
</pre>
</p>
<p><a name="LZ05b"></a><pre>
@INPROCEEDINGS{LZ05b,
  AUTHOR = {Peng Li and Steve Zdancewic},
  TITLE = {{Practical Information-flow Control in Web-based Information Systems}},
  BOOKTITLE = {Proc. of 18th IEEE Computer Security Foundations Workshop},
  YEAR = 2005,
  PAGES = {2--15},
  HCONF = {yes},
  PLCLUB = {yes},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ05b.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ05b.pdf</a>},
  ABSTRACT = {This paper presents a practical application of
  language-based information-flow control, namely, a domain-specific
  web scripting language designed for interfacing with databases.  The
  primary goal is to provide strong enforcement of confidentiality and
  integrity policies: confidential data can be released only in
  permitted ways and trustworthy data must result from expected
  computations or conform to expected patterns.  Such security
  policies are specified in the database layer and statically enforced
  for the rest of the system in an end-to-end fashion.

  In contrast with existing web-scripting languages, which provide
  only ad hoc mechanisms for information security, the scripting
  language described here uses principles based on the well-studied
  techniques in information-flow type systems.  However, because web
  scrips often need to downgrade confidential data and manipulate
  untrusted user input, they require practical and convenient ways of
  downgrading secure data.  To achieve this goal, the language allows
  safe downgrading according to \emph{downgrading policies} specified
  by the programmer.  This novel, pattern-based approach provides a
  practical instance of recent work on \emph{delimited release} and
  \emph{relaxed noninterference} and extends that work by accounting
  for integrity policies.  }
}
</pre>
</p>
<p><a name="LZ05"></a><pre>
@INPROCEEDINGS{LZ05,
  AUTHOR = {Peng Li and Steve Zdancewic},
  TITLE = {{Downgrading Policies and Relaxed Noninterference}},
  BOOKTITLE = {Proc. 32nd {ACM} Symp. on Principles of Programming
		  Languages (POPL)},
  YEAR = 2005,
  PAGES = {158--170},
  MONTH = JAN,
  HCONF = {yes},
  PLCLUB = {yes},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ05a.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ05a.pdf</a>},
  ABSTRACT = { In traditional information-flow type systems, the
    security policy is often formalized as noninterference properties.
    However, noninterference alone is too strong to express security
    properties useful in practice.  If we allow downgrading in such
    systems, it is challenging to formalize the security policy as an
    extensional property of the system.


    This paper presents a generalized framework of downgrading
  policies.  Such policies can be specified in a simple and tracable
  language and can be statically enforced by mechanisms such as type
  systems.  The security guarantee is then formalized as a concise
  extensional property using program equivalences.  This
  \textit{relaxed noninterference} generalizes traditional pure
  noninterference and precisely characterizes the information released
  due to downgrading.  
}
}
</pre>
</p>
<p><a name="LZ04a"></a><pre>
@INPROCEEDINGS{LZ04a,
  AUTHOR = {Peng Li and Steve Zdancewic},
  TITLE = {{Advanced Control Flow in Java Card Programming}},
  BOOKTITLE = {Proceedings of the 2004 ACM SIGPLAN/SIGBED Conference on Languages, 
                  Compilers, and Tools for Embedded Systems},
  PAGES = {165--174},
  YEAR = 2004,
  MONTH = JUN,
  HCONF = {yes},
  PLCLUB = {yes},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/LZ04a.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ04a.pdf</a>},
  ABSTRACT = {
Java Card technology simplifies the development of smart card
applications by providing a high-level programming language similar to
Java.  However, the master-slave programming model used in current
Java Card platform creates control flow difficulties when writing
complex card programs, making it inconvenient, tedious, and
error-prone to implement Java Card applications. This paper examines
these drawbacks of the master-slave model and proposes a concurrent
thread model for developing future Java Card programs, which is much
closer to conventional Java network programming.  This paper also
presents a code translation algorithm and a corresponding tool that
makes it possible to write card programs in the concurrent thread
model without losing compatibility with the existing Java Card API.
}
}
</pre>
</p>
<p><a name="TZ04a"></a><pre>
@INPROCEEDINGS{TZ04a,
  AUTHOR = {Stephen Tse and Steve Zdancewic},
  TITLE = {{Run-time Principals in Information-flow Type Systems}},
  BOOKTITLE = {IEEE 2004 Symposium on Security and Privacy},
  YEAR = 2004,
  MONTH = MAY,
  PUBLISHER = {{IEEE} Computer Society Press},
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ04a.ps">http://www.cis.upenn.edu/~stevez/papers/TZ04a.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ04a.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ04a.pdf</a>},
  ABSTRACT = {
  Information-flow type systems are a promising approach for enforcing
  strong end-to-end confidentiality and integrity policies. Such
  policies, however, are usually specified in term of static
  information--data is labeled \textit{high} or \textit{low} security at
  compile time.  In practice, the confidentiality of data may depend
  on information available only while the system is running
  

  This paper studies language support for \textit{run-time principals}, a
  mechanism for specifying information-flow security policies that
  depend on which principals interact with the system.  We establish
  the basic property of noninterference for programs written in such
  language, and use run-time principals for specifying run-time
  authority in downgrading mechanisms such as declassification.
  

  In addition to allowing more expressive security policies, run-time
  principals enable the integration of language-based security
  mechanisms with other existing approaches such as Java stack
  inspection and public key infrastructures. We sketch an
  implementation of run-time principals via public keys such that
  principal delegation is verified by certificate chains.
  }
}
</pre>
</p>
<p><a name="LMZ03"></a><pre>
@INPROCEEDINGS{LMZ03,
  AUTHOR = {Peng Li and Yun Mao and Steve Zdancewic},
  TITLE = {{Information Integrity Policies}},
  BOOKTITLE = {Proceedings of the Workshop on Formal Aspects in Security \& Trust (FAST)},
  YEAR = 2003,
  MONTH = SEP,
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/LMZ03.ps">http://www.cis.upenn.edu/~stevez/papers/LMZ03.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/LMZ03.pdf">http://www.cis.upenn.edu/~stevez/papers/LMZ03.pdf</a>},
  ABSTRACT = {Information integrity policies are traditionally enforced by
  access control mechanisms that prevent unauthorized users from
  modifying data.  However, access control does not provide end-to-end
  assurance of integrity.  For that reason, integrity guarantees in
  the form of noninterference assertions have been proposed.  Despite
  the appeals of such information-flow based approaches to integrity,
  that solution is also unsatisfactory because it leads to a weaker
  notion of integrity than needed in practice.
  

  This paper attempts to clarify integrity policies by
  comparing and contrasting access control vs. information flow,
  integrity vs. confidentiality policies, and
  integrity vs. availability policies.  The paper also examines data
  invariants as a way to strengthen integrity.  The result is a better
  classification of information-integrity policies.}
}
</pre>
</p>
<p><a name="WZL03"></a><pre>
@INPROCEEDINGS{WZL03,
  AUTHOR = {David Walker and Steve Zdancewic and Jay Ligatti},
  TITLE = {{A Theory of Aspects}},
  BOOKTITLE = {Proc. of the 8th ACM SIGPLAN International Conference on
		  Functional Programming},
  YEAR = 2003,
  ADDRESS = {Upsala, Sweden},
  MONTH = AUG,
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/WZL03.ps">http://www.cis.upenn.edu/~stevez/papers/WZL03.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/WZL03.pdf">http://www.cis.upenn.edu/~stevez/papers/WZL03.pdf</a>},
  ABSTRACT = {This paper define the semantics of MinAML, an idealized
aspect-oriented programming language, by giving 
a type-directed translation from its user-friendly external language
to its compact, well-defined core language.
We argue that our framework is an effective way
to give semantics to aspect-oriented programming languages in
general because the translation eliminates shallow syntactic differences
between related constructs and permits definition of a clean,
easy-to-understand, and easy-to-reason-about core language.


The core language extends the simply-typed lambda
calculus with two central new abstractions: explicitly labeled program
points and first-class advice.  The labels serve both to trigger
advice and to mark continuations that the advice may return to.  These
constructs are defined orthogonally to the other features of the
language and we show that our abstractions can be used in both
functional and object-oriented contexts.  The labels are well-scoped
and the language as a whole is well-typed.  Consequently, programmers
can use lexical scoping in the standard way to prevent aspects from
interfering with local program invariants.
  }
}
</pre>
</p>
<p><a name="SSDK+03"></a><pre>
@INPROCEEDINGS{SSDK+03,
  AUTHOR = {Usa Sammapun and Raman Sharykin and Margaret Delap and Myong Kim and Steve Zdancewic},
  TITLE = {{Formalizing {Java-MaC}}},
  BOOKTITLE = {Proceedings of the Third Runtime Verification Workshop},
  PUBLISHER = {Electronic Notes in Theoretical Computer Science},
  YEAR = 2003,
  MONTH = JUL,
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/SSDK03.ps">http://www.cis.upenn.edu/~stevez/papers/SSDK03.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/SSDK03.pdf">http://www.cis.upenn.edu/~stevez/papers/SSDK03.pdf</a>},
  ABSTRACT = {The Java-MaC framework is a run-time verification system for Java
  programs that can be used to dynamically test and enforce safety
  policies.  This paper presents a formal model of the Java-MaC safety
  properties in terms of an operational semantics for Middleweight
  Java, a realistic subset of full Java.  This model is intended to be
  used as a framework for studying the correctness of Java-MaC program
  instrumentation, optimizations, and future experimentation with
  run-time monitor expressiveness.  As a preliminary demonstration of this model's
  applicability for these tasks, the paper sketches a correctness result
  for a simple program instrumentation scheme.
  }
}
</pre>
</p>
<p><a name="ZM03"></a><pre>
@INPROCEEDINGS{ZM03,
  AUTHOR = {Steve Zdancewic and Andrew C. Myers},
  TITLE = {{Observational Determinism for Concurrent Program Security}},
  BOOKTITLE = {Proc. of 16th IEEE Computer Security Foundations Workshop},
  YEAR = 2003,
  MONTH = JUL,
  ADDRESS = {Asilomar, CA},
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZMO3.ps">http://www.cis.upenn.edu/~stevez/papers/ZMO3.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZMO3.pdf">http://www.cis.upenn.edu/~stevez/papers/ZMO3.pdf</a>},
  ABSTRACT = {Noninterference is a property of sequential programs that is useful
for expressing security policies for data confidentiality and
integrity. However, extending noninterference to concurrent programs has
proved problematic. In this paper we present a relatively expressive
secure concurrent language. This language, based on existing
concurrent calculi, provides first-class channels, higher-order
functions, and an unbounded number of threads.  Well-typed programs
obey a generalization of noninterference that ensures
immunity to internal
timing attacks and to attacks that exploit information about the thread
scheduler. Elimination of these refinement attacks is possible because
the enforced security property extends noninterference with
observational determinism. Although the security property is strong,
it also avoids some of the restrictiveness imposed on 
previous security-typed concurrent languages.
}
}
</pre>
</p>
<p><a name="GGKS+03"></a><pre>
@INPROCEEDINGS{GGKS+03,
  AUTHOR = {Michael Greenwald and Carl A. Gunter and Bj\"{o}rn Knutsson and
                  Andre Scedrov and Jonathan M. Smith and Steve Zdancewic},
  TITLE = {{Computer Security is Not a Science (but it should be)}},
  BOOKTITLE = {Proceedings of the Large-Scale Network Security Workshop},
  YEAR = 2003,
  MONTH = MAR,
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {GGKS+http://www.cis.upenn.edu/~stevez/papers/03.ps},
  PDF = {GGKS+http://www.cis.upenn.edu/~stevez/papers/03.pdf}
}
</pre>
</p>
<p><a name="ZCZM03"></a><pre>
@INPROCEEDINGS{ZCZM03,
  AUTHOR = {Lantian Zheng and Stephen Chong and Steve Zdancewic
                  and Andrew C. Myers},
  TITLE = {{Building Secure Distributed Systems Using Replication and 
                  Partitioning}},
  BOOKTITLE = {IEEE 2003 Symposium on Security and Privacy},
  YEAR = 2003,
  PUBLISHER = {{IEEE} Computer Society Press},
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZCZM03.ps">http://www.cis.upenn.edu/~stevez/papers/ZCZM03.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZCZM03.pdf">http://www.cis.upenn.edu/~stevez/papers/ZCZM03.pdf</a>},
  ABSTRACT = {A challenging unsolved security problem is how to
specify and enforce system-wide security policies; this problem is
even more acute in distributed systems with mutual distrust. This
paper describes a way to enforce policies for data confidentiality and
integrity in such an environment. Programs annotated with security
specifications are statically checked and then transformed by the
compiler to run securely on a distributed system with untrusted
hosts. The code and data of the computation are partitioned across the
available hosts in accordance with the security specification.  The
key contribution is automatic replication of code and data to increase
assurance of integrity---without harming confidentiality, and without
placing undue trust in any host.  The compiler automatically generates
secure run-time protocols for communication among the replicated code
partitions. Results are given from a prototype implementation applied
to various distributed programs.  }
}
</pre>
</p>
<p><a name="ZZNM01"></a><pre>
@INPROCEEDINGS{ZZNM01,
  YEAR = 2001,
  AUTHOR = {Steve Zdancewic and Lantian Zheng and Nathaniel Nystrom
		  and Andrew C. Myers},
  TITLE = {{Untrusted Hosts and Confidentiality: Secure Program Partitioning}},
  SERIES = {Operating Systems Review},
  BOOKTITLE = {Proc. 18th {ACM} Symp. on Operating System Principles (SOSP)},
  ADDRESS = {Banff, Canada},
  MONTH = OCT,
  VOLUME = {35(5)},
  PAGES = {1--14},
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM01.ps">http://www.cis.upenn.edu/~stevez/papers/ZZNM01.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM01.pdf">http://www.cis.upenn.edu/~stevez/papers/ZZNM01.pdf</a>},
  ABSTRACT = {This paper presents secure program partitioning, a
  language-based technique for protecting confidential data during
  computation in distributed systems containing mutually untrusted
  hosts. Confidentiality and integrity policies can be expressed by
  annotating programs with security types that constrain information
  flow; these programs can then be partitioned automatically to run
  securely on heterogeneously trusted hosts. The resulting
  communicating subprograms collectively implement the original
  program, yet the system as a whole satisfies the security
  requirements of participating principals without requiring a
  universally trusted host machine. The experience in applying this
  methodology and the performance of the resulting distributed code
  suggest that this is a promising way to obtain secure distributed
  computation. }
}
</pre>
</p>
<p><a name="ZM01b"></a><pre>
@INPROCEEDINGS{ZM01b,
  AUTHOR = {Steve Zdancewic and Andrew C. Myers},
  TITLE = {{Robust Declassification}},
  BOOKTITLE = {Proc. of 14th IEEE Computer Security Foundations Workshop},
  MONTH = JUN,
  YEAR = 2001,
  ADDRESS = {Cape Breton, Canada},
  PAGES = {15--23},
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM01b.ps">http://www.cis.upenn.edu/~stevez/papers/ZM01b.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM01b.pdf">http://www.cis.upenn.edu/~stevez/papers/ZM01b.pdf</a>},
  ABSTRACT = { Security properties based on information flow, such as
  noninterference, provide strong guarantees that confidentiality is
  maintained. However, programs often need to leak some amount of
  confidential information in order to serve their intended purpose,
  and thus violate noninterference. Real systems that control
  information flow often include mechanisms for downgrading or
  declassifying information; however, declassification can easily
  result in the unexpected release of confidential information.


This paper introduces a formal model of information flow in systems
that include intentional information leaks and shows how to
characterize what information leaks. Further, we define a notion of
robustness for systems that include information leaks introduced by
declassification. Robust systems have the property that an attacker is
unable to exploit declassification channels to obtain more
confidential information than was intended to be released. We show
that all systems satisfying a noninterference-like property are
robust; for other systems, robustness involves a nontrivial
interaction between confidentiality and integrity properties. We
expect this model to provide new tools for the characterization of
information flow properties in the presence of intentional information
leaks. }
}
</pre>
</p>
<p><a name="ZM01"></a><pre>
@INPROCEEDINGS{ZM01,
  AUTHOR = {Steve Zdancewic and Andrew C. Myers},
  TITLE = {{Secure Information Flow and {CPS}}},
  BOOKTITLE = {Proc. of the 10th European Symposium on Programming},
  YEAR = 2001,
  VOLUME = 2028,
  MONTH = APR,
  SERIES = {Lecture Notes in Computer Science},
  PAGES = {46--61},
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM01.ps">http://www.cis.upenn.edu/~stevez/papers/ZM01.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM01.pdf">http://www.cis.upenn.edu/~stevez/papers/ZM01.pdf</a>},
  ABSTRACT = {Security-typed languages enforce secrecy or integrity
  policies by type-checking. This paper investigates
  continuation-passing style as a means of proving that such languages
  enforce non-interference and as a first step towards understanding
  their compilation. We present a low-level, secure calculus with
  higher-order, imperative features. Our type system makes novel use
  of ordered linear continuations.}
}
</pre>
</p>
<p><a name="ZGM99"></a><pre>
@INPROCEEDINGS{ZGM99,
  AUTHOR = {Steve Zdancewic and Dan Grossman and Greg Morrisett},
  TITLE = {{Principals in Programming Languages: A Syntactic Proof Technique}},
  BOOKTITLE = {Proc. of the 4th ACM SIGPLAN International Conference on
		  Functional Programming},
  YEAR = 1999,
  PAGES = {197--207},
  ADDRESS = {Paris, France},
  MONTH = SEP,
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZGM99.ps">http://www.cis.upenn.edu/~stevez/papers/ZGM99.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZGM99.pdf">http://www.cis.upenn.edu/~stevez/papers/ZGM99.pdf</a>},
  ABSTRACT = {Programs are often structured around the idea that
  different pieces of code comprise distinct principals, each with a
  view of its environment. Typical examples include the modules of a
  large program, a host and its clients, or a collection of
  interactive agents.


In this paper, we formalize this notion of principal in the
programming language itself. The result is a language in which
intuitive statements such as, ``the client must call open to obtain a
file handle'', can be phrased and proven formally.


We add principals to variants of the simply-typed lambda-calculus and
show how we can track the code corresponding to each principal
throughout evaluation. This multiagent calculus yields syntactic
proofs of some type abstraction properties that traditionally require
semantic arguments.}
}
</pre>
</p>
<p><a name="MCGG+99"></a><pre>
@INPROCEEDINGS{MCGG+99,
  AUTHOR = {Greg Morrisett and Karl Crary and Neal Glew and Dan
		  Grossman and Richard Samuels and Frederick Smith and David
		  Walker and Stephanie Weirich and Steve Zdancewic},
  TITLE = {{{TALx86}: A Realistic Typed Assembly Language}},
  BOOKTITLE = {2nd {ACM SIGPLAN} Workshop on Compiler Support for
		  System Software},
  YEAR = 1999,
  PAGES = {25--35},
  HCONF = {yes},
  PLCLUB = {yes},
  PS = {MCGG+http://www.cis.upenn.edu/~stevez/papers/99.ps},
  PDF = {MCGG+http://www.cis.upenn.edu/~stevez/papers/99.pdf},
  ABSTRACT = {The goal of typed assembly language (TAL) is to provide
  a low-level, statically typed target language that is better suited
  than Java bytecodes for supporting a wide variety of source
  languages and a number of important optimizations. In previous work,
  we formalized idealized versions of TAL and proved important safety
  properties about them. In this paper, we present our progress in
  defining and implementing a realistic typed assembly language called
  TALx86. The TALx86 instructions comprise a relatively complete
  fragment of the Intel IA32 (32-bit 80x86 flat model) assembly
  language and are thus executable on processors such as the Intel
  Pentium. The type system for the language incorporates a number of
  advanced features necessary for safely compiling large programs to
  good code.


To motivate the design of the type system, we demonstrate how various
high-level language features are compiled to TALx86. For this purpose,
we present a type-safe C-like language called Popcorn.}
}
</pre>
</p>
<p><a name="TZ05atr"></a><pre>
@TECHREPORT{TZ05atr,
  AUTHOR = {Stephen Tse and Steve Zdancewic},
  TITLE = {{Designing a Security-typed Language with Certificate-based Declassification}},
  INSTITUTION = {University of Pennsylvania},
  NUMBER = {MIS-CIS-04-16},
  YEAR = 2004,
  HTR = {yes},
  PLCLUB = {yes},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ05atr.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ05atr.pdf</a>},
  ABSTRACT = {This paper presents the design of a programming language that
  supports information-flow security policies and certificate-based
  declassification.

  
  The language uses monadic information-flow annotations in the style
  of Abadi et al.'s dependency core calculus, and has an effects
  system and fixpoints. The type system conflates security concepts
  such as labels, principals, and privileges with abstract types,
  allowing a uniform treatment of lattice structures throughout the
  language.  Myers' and Liskov's decentralized label model is encoded
  using type constructors that describe confidentiality and integrity
  policies, and label refinements and principal groups follow
  naturally from intersection and union types.  Singleton types,
  combined with bounded universal and existential quantifications,
  connect the type system with public-key infrastructures whose
  digital certificates provide authorization for privileged operations
  such as declassification.  These features allow specification of
  security policies in term of dynamic entities such as run-time user
  identities and file access permissions.

  
  Besides showing that the language is sound, we present a security
  theorem that generalizes standard noninterference to account for
  information flows introduced by declassification.  Although this
  result gives only a coarse approximation to the information
  potentially leaked, it captures our intuitions about
  certificate-based declassification.
  }
}
</pre>
</p>
<p><a name="TZ04c"></a><pre>
@TECHREPORT{TZ04c,
  AUTHOR = {Stephen Tse and Steve Zdancewic},
  TITLE = {{Translating Dependency into Parametricity}},
  INSTITUTION = {University of Pennsylvania},
  YEAR = 2004,
  NUMBER = {MIS-CIS-04-01},
  HTR = {yes},
  PLCLUB = {yes},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ04btr.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ04btr.pdf</a>},
  ABSTRACT = {
  The \textit{dependency core calculus} (DCC) was introduced by Abadi
  et al. as a unifying formal framework in which to study a variety of
  important program analyses including binding-time, information-flow,
  slicing, and function call tracking. The novel feature of DCC is a
  lattice of monads and a nonstandard typing rule for their associated
  \texttt{bind} operations.  Intuitively, the lattice structure describes
  which computations in a program may depend on each other.  Abadi et
  al.  prove a \textit{noninterference} result that establishes the
  correctness of DCC's type system, and they use that result to show
  that type systems for the above-mentioned analyses are correct.
  
  In this paper, we study the relationship between DCC and the
  Girard--Reynolds polymorphic lambda calculus (System F).  In
  particular, we show how to encode the recursion-free fragment of DCC
  into F via a type-directed translation.  The main theorem we present
  uses this translation to derive the noninterference result for DCC
  from the standard parametricity theorem of System F.  In addition to
  providing insight into DCC's type system, the hope is that the
  translation presented here may yield implementation strategies for
  non-standard type systems (e.g. for information flow security) in
  languages that have parametric polymorphism.
  }
}
</pre>
</p>
<p><a name="TZ03"></a><pre>
@TECHREPORT{TZ03,
  AUTHOR = {Stephen Tse and Steve Zdancewic},
  TITLE = {{Run-time Principals in Information-flow Type Systems}},
  INSTITUTION = {University of Pennsylvania},
  YEAR = 2003,
  NUMBER = {MS-CIS-03-39},
  NOTE = {The conference version appears in {IEEE} Security and Privacy 2004},
  HTR = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ03.ps">http://www.cis.upenn.edu/~stevez/papers/TZ03.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/TZ03.pdf">http://www.cis.upenn.edu/~stevez/papers/TZ03.pdf</a>},
  ABSTRACT = {
  Information-flow type systems are a promising approach for enforcing
  strong end-to-end confidentiality and integrity policies. Such
  policies, however, are usually specified in term of static
  information--data is labeled \textit{high} or \textit{low} security at
  compile time.  In practice, the confidentiality of data may depend
  on information available only while the system is running

  
  This paper studies language support for \textit{run-time principals}, a
  mechanism for specifying information-flow security policies that
  depend on which principals interact with the system.  We establish
  the basic property of noninterference for programs written in such
  language, and use run-time principals for specifying run-time
  authority in downgrading mechanisms such as declassification.

  
  In addition to allowing more expressive security policies, run-time
  principals enable the integration of language-based security
  mechanisms with other existing approaches such as Java stack
  inspection and public key infrastructures. We sketch an
  implementation of run-time principals via public keys such that
  principal delegation is verified by certificate chains.
  }
}
</pre>
</p>
<p><a name="ZZNM01b"></a><pre>
@TECHREPORT{ZZNM01b,
  YEAR = 2001,
  TITLE = {{Secure Program Partitioning}},
  AUTHOR = {Steve Zdancewic and Lantian Zheng and Nathaniel Nystrom
		  and Andrew C. Myers},
  INSTITUTION = {Computer Science Dept., Cornell University},
  NUMBER = {2001-1846},
  HTR = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM01b.ps">http://www.cis.upenn.edu/~stevez/papers/ZZNM01b.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZZNM01b.pdf">http://www.cis.upenn.edu/~stevez/papers/ZZNM01b.pdf</a>},
  ABSTRACT = {This paper presents secure program partitioning, a
  language-based technique for protecting confidential data during
  computation in distributed systems containing mutually untrusted
  hosts. Confidentiality and integrity policies can be expressed by
  annotating programs with security types that constrain information
  flow; these programs can then be partitioned automatically to run
  securely on heterogeneously trusted hosts. The resulting
  communicating subprograms collectively implement the original
  program, yet the system as a whole satisfies the security
  requirements of participating principals without requiring a
  universally trusted host machine. The experience in applying this
  methodology and the performance of the resulting distributed code
  suggest that this is a promising way to obtain secure distributed
  computation.


This Technical Report is an expanded version of the published paper
``Untrusted Hosts and Confidentiality: Secure Program Partitioning''.
The main difference between the two is Appendix A, which contains a
correctness proof for the control-transfer protocols described in
Section 5.}
}
</pre>
</p>
<p><a name="ZM00"></a><pre>
@TECHREPORT{ZM00,
  AUTHOR = {Steve Zdancewic and Andrew C. Myers},
  TITLE = {{Confidentiality and Integrity with Untrusted Hosts}},
  INSTITUTION = {Computer Science Dept., Cornell University},
  YEAR = 2000,
  NUMBER = {2000-1810},
  HTR = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM00.ps">http://www.cis.upenn.edu/~stevez/papers/ZM00.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZM00.pdf">http://www.cis.upenn.edu/~stevez/papers/ZM00.pdf</a>},
  ABSTRACT = {Several \emph{security-typed languages} have recently been proposed to enforce
security properties such as confidentiality or integrity by type checking.
We propose a new security-typed language, Spl@, that
addresses two important limitations of previous approaches.


First, existing languages assume that the underlying execution platform
is trusted; this assumption does not scale to distributed computation in
which a variety of differently trusted hosts are available to execute
programs. Our new approach, \emph{secure program partitioning}, translates
programs written assuming complete trust in a single executing host into
programs that execute using a collection of variously trusted hosts to
perform computation.  As the trust configuration of a distributed system
evolves, this translation can be performed as necessary for security.


Second, many common program transformations do not work in existing
security-typed languages; although they produce equivalent
programs, these programs are rejected because of \emph{apparent} information
flows. Spl@ uses a novel mechanism
based on \emph{ordered linear continuations} to permit a richer class of program
transformations, including secure program partitioning.}
}
</pre>
</p>
<p><a name="ZG99"></a><pre>
@TECHREPORT{ZG99,
  AUTHOR = {Steve Zdancewic and Dan Grossman},
  TITLE = {{Principals in Programming Languages: Technical Results}},
  INSTITUTION = {Computer Science Dept., Cornell University},
  YEAR = 1999,
  NUMBER = {TR99-1752},
  MONTH = JUN,
  HTR = {yes},
  PLCLUB = {yes},
  PS = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZG99.ps">http://www.cis.upenn.edu/~stevez/papers/ZG99.ps</a>},
  PDF = {<a href="http://www.cis.upenn.edu/~stevez/papers/ZG99.pdf">http://www.cis.upenn.edu/~stevez/papers/ZG99.pdf</a>},
  ABSTRACT = {This is the companion technical report for ``Principals
  in Programming Languages: A Syntactic Proof Technique.'' See that
  document for a more readable version of these results.


In this paper, we describe two variants of the simply typed
lambda-calculus extended with a notion of principal. The results are
languages in which intuitive statements like ``the client must call
open to obtain a file handle'' can be phrased and proven formally.


The first language is a two-agent calculus with references and
recursive types, while the second language explores the possibility of
multiple agents with varying amounts of type information. We use these
calculi to give syntactic proofs of some type abstraction results that
traditionally require semantic arguments. }
}
</pre>
</p>
