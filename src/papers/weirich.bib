%% BIBTEX %%

@string{ACM  = "ACM"}
@string{SIGPLAN = "SIGPLAN"}

@string{cmu-cs = "Carnegie Mellon University, School of Computer Science"}
@string{cornell-cs = "Department of Computer Science, Cornell University"}
@string{dec-src = "Digital Equipment Corporation, Systems Research Center"}
@string{edin-cs = "Department of Computer Science, University of Edinburgh"}
@string{inria = "Institut National de Recherche en Informatique et Automatique (INRIA)"}
@string{yale-cs = "Yale University, Department of Computer Science"}

@string{proc = "Proceedings of the "}

%% Conferences
@string{cade = "International Conference on Automated Deduction"}
@string{csl = "International Workshop on Computer Science Logic (CSL)"}
@string{esop = "European Symposium on Programming (ESOP)"}
@string{fool = "Foundations of Object-Oriented Languages Workshop (FOOL)"}
@string{fpca = "Conference on Functional Programming Languages and Computer Architecture (FPLCA)"}
@string{icalp = "International Colloquium on Automata, Languages, and Programming"}
@string{icfp = "{ACM SIGPLAN} International Conference on Functional Programming (ICFP) "}
@string{lfp = "{ACM} Conference on {Lisp} and Functional Programming"}
@string{lics = "{IEEE} Symposium on Logic in Computer Science (LICS)"}
@string{mfps = "Mathematical Foundations of Programming Semantics (MFPS)"}
@string{osdi = "Symposium on Operating Systems Design and Implementation (OSDI)"}
@string{pldi = " {ACM SIGPLAN} Conference on Programming Language Design and Implementation (PLDI)"}
@string{popl = " {ACM}{SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages (POPL)"}
@string{sosp = " {ACM} Symposium on Operating Systems Principles (SOSP)"}
@string{tacs = "Theoretical Aspects of Computer Software (TACS)"}
@string{tlca = "International Conference on Typed Lambda Calculi and Applications (TLCA)"}
@string{sigmod = "Proc. {ACM} {SIGMOD} International
                  Conference on Management of Data"}
@string{oopsla = "{ACM} {SIGPLAN} Conference on Object-Oriented
                  Programming, Systems, Languages and Applications (OOPSLA)"}
@string{sigcomm = "Proc. {SIGCOMM} Symposium on Communications
                  Architectures and Protocols"}
@string{ieeesp = "IEEE Symposium on Research in Security and Privacy"}
@string{rtss = "Real-Time Systems Symposium"}

%% Workshops
@string{tic = "{ACM} {SIGPLAN} Workshop on Types in Compilation"}
@string{wcsss = "{ACM}{SIGPLAN} Workshop on Compiler Support for System Software"}
@string{hotos = "Workshop on Hot Topis in Operating Systems"}
@string{lctes = "Proceedings of the {ACM} {SIGPLAN} Workshop on Languages, 
                 Compilers, and Tools for Embedded Systems (LCTES)"}
@string{pepm = "{ACM} {SIGPLAN} Workshop on Partial Evaluation and
                  Semantics-Based Program Manipulation (PEPM)"}
@string{hoots = "International Workshop on Higher Order Operational Techniques in Semantics (HOOTS)"}
@string{tldi = {ACM SIGPLAN Workshop on Types in Language Design and Implementation (TLDI)}}

%% Journals
@string{iandc = "Information and Computation"}
@string{jacm = "Journal of the {ACM}"}
@string{jfp = "Journal of Functional Programming"}
@string{mscs = "Mathematical Structures in Computer Science"}
@string{tcs = "Theoretical Computer Science"}
@string{toplas = "{ACM} Transactions on Programming Languages and Systems"}
@string{tse = "{IEEE} Transactions on Software Engineering"}
@String{j-LISP-SYMB-COMPUT      = "Lisp and Symbolic Computation"}

@string{lncs = "Lecture Notes in Computer Science"}

@string{academic = "Academic Press"}
@string{addison = "Addison-Wesley"}
@string{cambridge-press = "Cambridge University Press"}
@string{chapman = "Chapman \& Hall"}
@string{elsevier = "Elsevier"}
@string{mit-press = "The MIT Press"}
@string{noholland = "North-Holland"}
@string{springer = "Springer-Verlag"}
@string{sigplan-notices = "{SIGPLAN} Notices"}
@string{cam-ma = "Cambridge, Massachusetts"}
@string{ith-ny = "Ithaca, New York"}
@string{pgh-pa = "Pittsburgh, Pennsylvania"}

@string{o1="First "}
@string{o2="Second "}
@string{o3="Third "}
@string{o4="Fourth "}
@string{o5="Fifth "}
@string{o6="Sixth "}
@string{o7="Seventh "}
@string{o8="Eighth "}
@string{o9="Ninth "}
@string{o10="Tenth "}
@string{o11="Eleventh "}
@string{o12="Twelfth "}
@string{o13="Thirteenth "}
@string{o14="Fourteenth "}
@string{o15="Fifteenth "}
@string{o16="Sixteenth "}
@string{o17="Seventeenth "}
@string{o18="Eighteenth "}
@string{o19="Nineteenth "}
@string{o20="Twentieth "}
@string{o21="Twenty-First "}
@string{o22="Twenty-Second "}
@string{o23="Twenty-Third "}
@string{o24="Twenty-Fourth "}
@string{o25="Twenty-Fifth "}
@string{o26="Twenty-Sixth "}
@string{o27="Twenty-Seventh "}


%% Ack for downloaded bib entry

@String{ack-nhfb = "Nelson H. F. Beebe,
                    Center for Scientific Computing,
                    University of Utah,
                    Department of Mathematics, 322 INSCC,
                    155 S 1400 E RM 233,
                    Salt Lake City, UT 84112-0090, USA,
                    Tel: +1 801 581 5254,
                    FAX: +1 801 585 1640, +1 801 581 4148,
                    e-mail: \path|beebe@math.utah.edu|,
                            \path|beebe@acm.org|,
                            \path|beebe@ieee.org| (Internet),
                    URL: \path|http://www.math.utah.edu/~beebe/|"}


{ACM} {SIGPLAN}-{SIGACT}



# Note!  unpublished puts in draft section. misc does not.
#

@string{dl = "http://www.cis.upenn.edu/~sweirich/papers/"}
@string{tdl = "http://www.cs.cornell.edu/talc/papers/"}

@Unpublished{vytiniotis+:boxy,
  author = 		  {Dimitrios Vytiniotis and Stephanie Weirich and Simon {Peyton Jones}},
  title = 		  {Boxy type inference for higher-rank types and impredicativity},
  note = 		  {Submitted for publication},
  month = apr,
  year = 2005,
  ps = dl # "boxy/boxy.ps",
  plclub = "yes",
  abstract = {
Languages with rich type systems are beginning to employ a blend of type
inference and type checking, so that the type inference engine is
guided by programmer-supplied type annotations.  In this paper we show,
for the first time, how to combine the virtues of two well-established ideas: unification-based 
inference, and bidirectional propagation of type annotations.  The result 
is a type system that conservatively extends Hindley-Milner, and yet supports
both higher-rank and impredicative types.
}
}


@InProceedings{dantas+:polyaml,
  author = 		  {Daniel S. Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  title = 		  {{PolyAML}: A polymorphic aspect-oriented functional programmming language},
  booktitle =    icfp,
  month =		  sep,
  year =			  2005,
  address =      {Tallinn, Estonia},
  pdf =          {http://www.cis.upenn.edu/proj/plclub/polyaml/icfp2005.pdf},
  abstract = {
This paper defines PolyAML, a typed functional and aspect-oriented
programming language.  The main contribution of PolyAML is in the
seamless integration of polymorphism, run-time type analysis and
aspect-oriented programming language features.  In particular, PolyAML
allows programmers to define type-safe polymorphic advice using pointcuts
constructed from a collection of polymorphic join points.  PolyAML
also comes equipped with a type inference algorithm that conservatively
extends Hindley-Milner type inference.  In order to support first-class
polymorphic point-cut designators, a crucial feature for developing
aspect-oriented profiling or logging libraries, the algorithm blends the
conventional Hindley-Milner type inference algorithm with a simple form
of local type inference.

We give our language operational meaning via a type-directed
translation into an expressive type-safe intermediate language.  Many
complexities of the source language are eliminated in this
translation, leading to a modular specification of its semantics.  One
of the novelties of the intermediate language is the definition of
polymorphic labels for marking control-flow points.  These labels are
organized in a tree structure such that a parent in the tree serves as
a representative for the collection of all its children.  Type safety
requires that the type of each child is a generic instance of the type
of the polymorphic parent.  Similarly, when a set of labels is
assembled as a pointcut, the type of each label is an instance of the
type of the pointcut.
}
}


@TechReport{peyton-jones+:practical-appendix,
  author = 		  {Dimitrios Vytiniotis and Stephanie Weirich and Simon L. {Peyton Jones}},
  title = 		  {Practical type infreence for arbitrary-rank types ({T}echnical appendix)},
  institution =  {University of Pennsylvania},
  year = 		  2005,
  number =		  {MIS-CIS-05-14},
  url =          { http://www.cis.upenn.edu/~dimitriv/arbitrary-rank/MS-CIS-05-14.ps }
}

@unpublished{peyton-jones+:practical,
  author = 		  {Simon L. {Peyton Jones} and Dimitrios Vytiniotis and Stephanie Weirich and Mark Shields},
  title = 		  {Practical type inference for arbitrary-rank types},
  month =        jul,
  year =			  2005,
  url  =         {http://research.microsoft.com/%7Esimonpj/papers/higher-rank/putting.ps.gz}, 

  abstract = {Haskell's popularity has driven the need for ever more
  expressive type system features, most of which threaten the
  decidability and practicality of Damas-Milner type inference. One
  such feature is the ability to write functions with higher-rank
  types --- that is, functions that take polymorphic functions as
  their arguments.

Complete type inference is known to be undecidable for higher-rank
(impredicative) type systems, but in practice programmers are more
than willing to add type annotations to guide the type inference
engine, and to document their code. However, the choice of just what
annotations are required, and what changes are required in the type
system and its inference algorithm, has been an ongoing topic of
research.

We take as our starting point a lambda-calculus proposed by Odersky
and Laufer. Their system supports arbitrary-rank polymorphism through
the exploitation of type annotations on lambda-bound arguments and
arbitrary sub-terms. Though elegant, and more convenient than some
other proposals, Odersky and Laufer's system requires many
annotations. We show how to use local type inference (invented by
Pierce and Turner) to greatly reduce the annotation burden, to the
point where higher-rank types become eminently usable.

Higher-rank types have a very modest impact on type inference. We
substantiate this claim in a very concrete way, by presenting a
complete type-inference engine, written in Haskell, for a traditional
Damas-Milner type system, and then showing how to extend it for
higher-rank types. We write the type-inference engine using a monadic
framework: it turns out to be a particularly compelling example of
monads in action.

The paper is long, but is strongly tutorial in style. }

}

@InProceedings{mmm,
  author = 		  { Brian E. Aydemir and Aaron Bohannon and Matthew Fairbairn and J. Nathan Foster and Benjamin C. Pierce and Peter Sewell and Dimitrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich and Steve Zdancewic},
  title = 		  {Mechanized Metatheory for the Masses: The {POPLmark} Challenge},
  booktitle = 		  {The 18th International Conference on Theorem Proving in Higher Order Logics},
  month =		  aug,
  year =			  2005,
  address =      {Oxford, UK},
  ps = {http://www.cis.upenn.edu/proj/plclub/mmm/poplmark/poplmark.ps},
  pdf = {http://www.cis.upenn.edu/proj/plclub/mmm/poplmark/poplmark.pdf},
  abstract = {How close are we to a world where every paper on
programming languages is accompanied by an electronic appendix with
machine-checked proofs?

We propose a concrete set of benchmarks for measuring progress in this
area.  Based on the metatheory of System \FSUB, a typed
lambda-calculus with second-order polymorphism, subtyping, and
records, these benchmarks embody many aspects of programming languages
that are challenging to formalize: variable binding at both the term
and type levels, syntactic forms with variable numbers of components
(including binders), and proofs demanding complex induction
principles.  We hope that these benchmarks will help clarify the
current state of the art, provide a basis for comparing competing
technologies, and motivate further research.  }
}

#  ps =           "http://www.cis.upenn.edu/~geoffw/research/papers/lics2005.ps",
#  pdf =          "http://www.cis.upenn.edu/~geoffw/research/papers/lics2005.pdf",


@InProceedings{washburn+:seckinds,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Generalizing Parametricity Using Information Flow},
  booktitle =    lics,
  year =			  2005,
  month =        jun, 
  address =      {Chicago, IL, USA},
  ps =           dl # "seckinds/lics2005.ps",
  pdf =          dl # "seckinds/lics2005.pdf",
  abstract = {Run-time type analysis allows programmers to easily and
concisely define many operations based upon type structure, such as
serialization, iterators, and structural equality.  However, when
types can be inspected at run time, nothing is secret.  A module
writer cannot use type abstraction to hide implementation details from
clients: those clients can use type analysis to determine the
structure of these supposedly ``abstract'' data types.  Furthermore,
access control mechanisms do not help in isolating the implementation
of abstract datatypes from their clients.  Buggy or malicious
authorized modules may simply leak type information to unauthorized
clients, so module implementors cannot reliably tell which parts of a
program rely on their type definitions and which parts do not.

Currently, module implementors rely on parametric polymorphism to
provide guarantees about the use of their abstract datatypes.
Standard type parametricity does not hold for a language with run-time
type analysis, but in this paper we show how to generalize the
statement of parametricity so that it does hold in the presence of
type analysis and still encompasses the integrity and confidentiality
policies that are normally derived from parametricity.  The key is to
augment the type system with annotations about information flow.
Because the type system tracks the flow of dynamic type information,
the implementor of an abstract data type can easily see what parts of
the program depend on the implementation of a given type.  
} }

@Unpublished{peyton-jones+:wobbly,
  author = 		  {Simon {Peyton Jones} and Geoffrey Washburn and 
                 Stephanie Weirich},
  title = 		  {Wobbly types: Practical Type Inference for Generalised 
                  Algebraic Dataypes},
  note =         {15 pages}, 
  month =        jul,
  year =			  2004,
  ps =           dl # "gadt/gadt_jul04.ps",
  pdf =          dl # "gadt/gadt_jul04.pdf"
}

@misc{dantas+:poly-aspects,
  author = 		  {Dan S. Dantas and David Walker and Geoffrey Washburn and 
                  Stephanie Weirich},
  title = 		  {Analyzing Polymorphic Advice},
  month =		  oct,
  year =			  2004,
  pdf =          "http://www.cis.upenn.edu/~geoffw/research/papers/poly-aspect.pdf",
  ps =           "http://www.cis.upenn.edu/~geoffw/research/papers/poly-aspect.ps",
  note =         {25 pages. An extended version of this paper is Princeton University Computer 
                  Science Technical Report TR-717-04}
}

@TechReport{dantas+:poly-aspects-tr,
  author = 		  {Dan S. Dantas and David Walker and Geoffrey Washburn and 
                  Stephanie Weirich},
  title = 		  {Analyzing Polymorphic Advice},
  note = 		  {24 pages.},
  month =		  dec,
  institution =  {Princeton University Computer Science},
  number =       {TR-717-04},         
  year =			  2004,
  pdf =          "http://ncstrl.cs.princeton.edu/expand.php?id=TR-717-04",

  abstract = { We take one of the first steps towards developing a
   practical, statically-typed, functional, aspect-oriented
   programming language by showing how to integrate polymorphism and
   type analysis with aspect-oriented programming features.  In
   particular, we demonstrate how to define type-safe polymorphic
   advice using pointcuts that unify a collection of polymorphic join
   points.  We also introduce a new mechanism for specifying
   context-sensitive advice that involves pattern matching against the
   current stack of activation records, and meshes well with
   functional programming idioms.  We give our language meaning via a
   type-directed translation into an expressive, but fairly simple,
   type-safe intermediate language.  Many complexities of the source
   language are eliminated in this translation, leading to a modular
   specification of its semantics.  One of the novelties of the
   intermediate language is the definition of polymorphic labels for
   marking control-flow points.  These labels are organized in a tree
   structure such that a parent in the tree serves as a representative
   for the collection of all its children.  Type safety requires that
   the type of each child is a generic instance of the type of the
   polymorphic parent.  Similarly, when a set of labels is assembled
   as a pointcut, the type of each label is an instance of the type of
   the pointcut.
  }
}


@unpublished{washburn+:bgb-journal,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Boxes Go Bananas: {E}ncoding Higher-order
                  Abstract Syntax with Parametric Polymorphism},
  month =        oct,
  year =         2004,
  note =         {64 pages. Submitted for publication to {\em Journal of Functional Programming}}
}

@InProceedings{weirich+:tdj,
  plclub =       "yes",
  author = 		  {Stephanie Weirich and Liang Huang},
  title = 		  {A Design for Type-Directed {Java}},
  booktitle = 	  {Workshop on Object-Oriented Developments},
  year =			  2004,
  editor =		  {Viviana Bono},
  series =		  {ENTCS},
  note =			  {20 pages. An extended version (49 pages) of this paper is 
                  University of Pennsylvania 
                  Computer and Information Science Technical Report 
                  MS-CIS-04-11.},

  ps = "http://www.cis.upenn.edu/%7Elhuang3/pubs/tdj-short.ps",
  pdf = "http://www.cis.upenn.edu/%7Elhuang3/pubs/tdj-short.pdf",
  abstract = {   
  Type-directed programming is an important and widely used
  paradigm in the design of software. With this form of programming,
  an application may analyze type information to determine its
  behavior. By analyzing the structure of data, many operations, such
  as serialization, cloning, adaptors and iterators may be defined
  once, for all types of data. That way, as the program evolves, these
  operations need not be updated---they will automatically adapt to
  new data forms.  Otherwise, each of these operations must be
  individually redefined for each type of data, forcing programmers to
  revisit the same program logic many times during a program's
  lifetime.

  The Java language supports type directed programming with the
  instanceof operator and the Java Reflection API.  These
  mechanisms allow Java programs to depend on the name and structure
  of the run-time classes of objects.  However, the Java mechanisms
  for type-directed programming are difficult to use. They also do not
  integrate well with generics, an important new feature of the Java
  language.

  In this paper, we describe the design of several expressive new
  mechanisms for type-directed programming in Java, and show that
  these mechanisms are sound when included in a language similar to
  Featherweight Java. Basically, these new mechanisms pattern-match
  the name and structure of the type parameters of generic code,
  instead of the run-time classes of objects.  Therefore, they
  naturally integrate with generics and provide strong guarantees
  about program correctness. As these mechanisms are based on pattern
  matching, they naturally and succinctly express many operations that
  depend on type information. Finally, they provide programmers with
  some degree of protection for their abstractions. Whereas
  instanceof and reflection can determine the exact run-time type
  of an object, our mechanisms allow any supertype to be supplied for
  analysis, hiding its precise structure.}
}

@Article{weirich:cast-journal,
  plclub =       "yes",
  author = 		  {Stephanie Weirich},
  title = 		  {Type-Safe Cast},
  journal = 	  jfp,
  month =        nov,
  year = 		  2004,
  volume =       14, 
  number =       6,
  pages =        {681-695},
  pdf =          {http://journals.cambridge.org/bin/bladerunner?REQUNIQ=1098990699&REQSESS=1422511&118000REQEVENT=&REQINT1=254715&REQAUTH=0},
  abstract =     {   Comparing two types for equality is an essential ingredient for an
  implementation of dynamic types. Once equality has been established,
  it is safe to cast a value from one type to another. In a language
  with run-time type analysis, implementing such a procedure is fairly
  straightforward.  Unfortunately, this naive implementation destructs
  and rebuilds the argument while iterating over its type structure.
  However, by using higher-order polymorphism, a casting function can
  treat its argument parametrically. We demonstrate this solution in
  two frameworks for ad-hoc polymorphism: intensional type analysis
  and Haskell type classes.}
}

%% submitted for publication
@unpublished{weirich:erasure,
  author = 		  {Stephanie Weirich},
  title = 		  {Higher-order Intensional Type Analysis in 
                  Type Erasure Semantics},
  year = 		  {2004},
  note =         {29 pages. Accepted to {\em Journal of Functional Programming}, pending revision }
}

@TechReport{huang+:tdp-tr,
  plclub =       "yes",
  author = 		  {Liang Huang and Stephanie Weirich},
  title = 		  {A Design for Type-Directed Programming in {Java}
                 (Extended Version)},
  institution =  {University of Pennsylvania, Computer and Information Science},
  year = 		  2004,
  number =		  {MS-CIS-04-11},
  month =		  oct,
  pages =        {1--49},
  ps =           dl # "tdj/ms-cis-04-11.ps",
  pdf =          dl # "tdj/ms-cis-04-11.pdf"
}

@InProceedings{vytiniotis+:itaname,
  author = 		  {Dimtrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich},
  title = 		  {An Open and Shut Typecase},
  booktitle = 	  tldi,
  year =			  2005,
  address =		  {Long Beach, CA, USA},
  month =		  jan,
  note =         {15 pages. An extended version of this paper (50 pages) 
                 is University of 
                 Pennsylvania Technical Computer and Information Science
                 Report MS-CIS-04-26},
  ps =           "http://www.cis.upenn.edu/~dimitriv/itaname/itaname.ps",
  abstract =     
{Two different ways of defining ad-hoc polymorphic operations commonly
occur in programming languages. With the first form polymorphic
operations are defined inductively on the structure of types while
with the second form polymorphic operations are defined for specific
sets of types.

In intensional type analysis operations are defined by induction on
the structure of types. Therefore no new cases are necessary for
user-defined types, because these types are equivalent to their
underlying structure.  However, intensional type analysis is
``closed'' to extension, as the behavior of the operations cannot be
differentiated for the new types, thus destroying the distinctions
that these types are designed to express.

Haskell type classes on the other hand define polymorphic operations
for sets of types. Operations defined by class instances are
considered ``open''---the programmer can add instances for new types
without modifying existing code. Howe ver, the operations must be
extended with specialized code for each new type, and it may be
tedious or even impossible to add extensions that apply to a large
universe of new types.

Both approaches have their benefits, so it is important to let
programmers decide which is most appropriate for their needs. In this
paper, we define a language that supports both forms of ad-hoc
polymorphism, using the same basic constructs.}

}

@TechReport{vytiniotis+:itaname-tr,
  author = 		  {Dimtrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich},
  title = 		  {An Open and Shut Typecase (Extended Version)},
  institution =  {University of Pennsylvania, Computer and Information Science},
  year = 		  2004,
  pages =        {1--50},
  number =		  {MS-CIS-04-26},
  month =		  oct,
  ps =           "http://www.cis.upenn.edu/~dimitriv/itaname/itaname-extended.ps"
}

## Superceded 

@misc{washburn+:mtr,  
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Unifying nominal and structural ad-hoc 
                  polymorphism (Extended version) },
  institution =  {University of Pennsylvania},
  year = 		  2004,
  month =		  mar,
  ps = "http://www.cis.upenn.edu/~geoffw/research/papers/itaname-report.ps", 
  pdf =       
  "http://www.cis.upenn.edu/~geoffw/research/papers/itaname.pdf", 

  abstract = "Ad-hoc polymorphism allows the execution of programs to
  depend on type information. In modern systems, it is useful for
  implementing generic operations over data structures, such as
  equality, marshalling, or traversal.  In the past, there have been
  two different forms of ad-hoc polymorphism. The nominal form
  dispatches on the name of the type argument, whereas the structural
  form operates by decomposing the structure of types. In languages
  with user-defined types, these two approaches are very
  different. Operations defined by the nominal approach are
  ``open''---they must be extended with specialized branches for
  user-defined types. In contrast, structurally defined operations are
  closed to extension. They automatically apply to user-defined types
  by treating them as their underlying definitions.  Both approaches
  have their benefits, so it important to provide both capabilities in
  a language. Therefore we present an expressive language that
  supports both forms of ad-hoc polymorphism in a single framework.
  Among the language's features are the ability to define both
  ``open'' and ``closed'' operations with a single mechanism, the
  ability to naturally restrict the domain of type-analyzing
  operations, and new mechanisms for defining higher-order polytypism
  and manipulating generative type definitions."  }
## Superceded

@misc{weirich:erasure-hota,
  author = 		  {Stephanie Weirich},
  title = 		  {Higher-Order Intensional Type Analysis 
                  in Type Erasure Semantics},
  note = 		  {Submitted for publication},
  month =		  jul,
  year =			  2003,
  ps =           dl # "erasure/erasure-paper-july03.ps",
  pdf =          dl # "erasure/erasure-paper-july03.pdf",
  abstract =     { Higher-order intensional type analysis is a way of defining
  type-indexed operations, such as map, fold and zip, based on
  run-time type information. However, languages supporting this
  facility are naturally defined with a type-passing semantics, which
  suffers from a number of drawbacks. This paper, describes how to
  recast higher-order intensional type analysis in a type-erasure
  semantics.  The resulting language is simple and easy to
  implement---we present a prototype implementation of the necessary
  machinery as a small Haskell library.},
  pages          = {1--29}
}

@TechReport{washburn+:itabox-tr,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Boxes Go Bananas: {E}ncoding Higher-order
                  Abstract Syntax with Parametric Polymorphism
                   (Extended version) },
  institution =  {University of Pennsylvania, Computer and Information Science },
  year = 		  2003,
  number =		  {MS-CIS-03-26},
  month =		  sep,
  ps =           dl # "itabox/MS-CIS-03-26.ps",
  pdf =          dl # "itabox/MS-CIS-03-26.pdf",
  annote =       "This paper is an extended version of \cite{washburn+:itabox}."
}


%  note =         "An extended and revised version of this paper 
%                 has been submitted for publication.", 

@InProceedings{washburn+:itabox,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Boxes Go Bananas: {E}ncoding Higher-order
                  Abstract Syntax with Parametric Polymorphism},
  booktitle =	  icfp,
  pages =		  {249--262},
  year =			  2003,
  address =		  {Uppsala, Sweden},
  month =		  aug,
  ps =           dl # "itabox/icfp-published-version.ps",
  pdf =          dl # "itabox/icfp-published-version.pdf",

  abstract = {Higher-order abstract syntax is a simple technique for
implementing languages with functional programming.  Object variables
and binders are implemented by variables and binders in the host
language.  By using this technique, one can avoid implementing common
and tricky routines dealing with variables, such as capture-avoiding
substitution.  However, despite the advantages this technique
provides, it is not commonly used because it is difficult to write
sound elimination forms (such as folds or catamorphisms) for
higher-order abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.

In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals.  From
this implementation, we derive ``fusion laws'' that functional
programmers may use to reason about the iteration operator.  Finally,
we show how this use of parametric polymorphism corresponds to the
Sch\"{u}rmann, Despeyroux and Pfenning method of enforcing
parametricity through modal types. We do so by using this library to
give a sound and complete encoding of their calculus into System \Fw.
This encoding can serve as a starting point for reasoning about
higher-order structures in polymorphic languages.  } }


@PhdThesis{weirich:phd,
  plclub =       "yes",
  author = 		  {Stephanie Weirich},
  title = 		  {Programming With Types},
  school = 		  {Cornell University},
  month =        aug,
  year =         2002,
  ps =           dl # "thesis/thesis.ps",
  pdf =          dl # "thesis/thesis.pdf",
  note =         {238 pages},
  abstract = 
     "Run-time type analysis is an increasingly important linguistic
     mechanism in modern programming languages. Language runtime
     systems use it to implement services such as accurate garbage
     collection, serialization, cloning and structural
     equality. Component frameworks rely on it to provide reflection
     mechanisms so they may discover and interact with program
     interfaces dynamically. Run-time type analysis is also crucial
     for large, distributed systems that must be dynamically extended,
     because it allows those systems to check program invariants when
     new code and new forms of data are added. Finally, many generic
     user-level algorithms for iteration, pattern matching, and
     unification can be defined through type analysis mechanisms.

     However, existing frameworks for run-time type analysis were
     designed for simple type systems. They do not scale well to the
     sophisticated type systems of modern and next-generation
     programming languages that include complex constructs such as
     first-class abstract types, recursive types, objects, and type
     parameterization. In addition, facilities to support type
     analysis often require complicated language semantics that allow
     little freedom in their implementation.  This dissertation
     investigates the foundations of run-time type analysis in the
     context of statically-typed, polymorphic programming languages.
     Its goal is to show how such a language may support
     type-analyzing operations in a way that balances expressiveness,
     safety and simplicity."

}

@InProceedings{weirich:hota,
  plclub =       "yes",
  author = 		  {Stephanie Weirich},
  title = 		  {Higher-Order Intensional Type Analysis},
  booktitle = 	  {11th } # esop,
  editor =		  {Daniel Le M\'{e}tayer},
  pages =        {98--114},
  year =         2002,
  month =        apr,
  address =      {Grenoble, France},
  ps =           dl # "hota/hota.ps",
  pdf =          dl # "hota/hota.pdf",

  abstract = "Intensional type analysis provides the ability to
     analyze abstracted types at run time. In this paper, we extend
     that ability to higher-order and kind-polymorphic type
     constructors. The resulting language is elegant and expressive:
     we show through examples how it extends the repertoire of
     polytypic functions that may be defined."
}


@Article{crary+:intensional-journal,
  author    = {Karl Crary and Stephanie Weirich and Greg Morrisett},
  title     = "Intensional Polymorphism in Type Erasure Semantics",
  journal   = jfp,
  month     = nov,
  year      = {2002},
  volume    = 12,
  number    = 6,
  pages     = {567--600},
  pdf       = {http://journals.cambridge.org/bin/bladerunner?REQUNIQ=1105036203&REQSESS=540959&118000REQEVENT=&REQINT1=129249&REQAUTH=0},
  abstract  = "Intensional polymorphism, the ability to dispatch to
     different routines based on types at run time, enables a variety
     of advanced implementation techniques for polymorphic languages,
     including tag-free garbage collection, unboxed function
     arguments, polymorphic marshalling, and flattened data
     structures. To date, languages that support intensional
     polymorphism have required a type-passing (as opposed to
     type-erasure) interpretation where types are constructed and
     passed to polymorphic functions at run time. Unfortunately,
     type-passing suffers from a number of drawbacks; it requires
     duplication of constructs at the term and type levels, it
     prevents abstraction, and it severely complicates polymorphic
     closure conversion.  We present a type-theoretic framework that
     supports intensional polymorphism, but avoids many of the
     disadvantages of type passing. In our approach, run-time type
     information is represented by ordinary terms. This avoids the
     duplication problem, allows us to recover abstraction, and avoids
     complications with closure conversion. In addition, our type
     system provides another improvement in expressiveness; it allows
     unknown types to be refined in place thereby avoiding certain
     beta-expansions required by other frameworks."
}

#  publisher =   "Springer",
#  series =      lncs,
#   volume =       2028,

@inproceedings{weirich01,
  plclub =       "yes",
  author =      "Stephanie Weirich",
  title =       {Encoding Intensional Type Analysis},
  booktitle =   "10th " # esop,
  year =        2001,
  editor =      "D. Sands",
  pages =       {92--106},
  address =     {Genova, Italy},
  month =       apr,
  annote =        "© 2001 Springer-Verlag. Minor corrections in local version.",
  url =         "http://link.springer.de/link/service/series/0558/tocs/t2028.htm",
  ps =          dl # "depabs/depabs.ps",
  pdf =         dl # "depabs/depabs.pdf",

  abstract = "Languages for intensional type analysis permit ad-hoc
     polymorphism, or run-time analysis of types. However, such
     languages require complex, specialized constructs to support this
     operation, which hinder optimization and complicate the
     meta-theory of these languages. In this paper, we observe that
     such specialized operators need not be intrinsic to the language,
     and in fact, their operation may be simulated through standard
     encodings of iteration in the polymorphic lambda
     calculus. Therefore, we may more easily add intensional analysis
     operators to complicated languages via a translation semantics,
     instead of through language extension."  }


%  note = {An extended and revised version of this paper is 
%          Journal Publication \cite{weirich:cast-journal}.}
@inproceedings{weirich00,
  plclub =       "yes",
  author =       "Stephanie Weirich",
  title  =       "Type-Safe Cast: Functional Pearl",
  booktitle =    proc # o5 # icfp,
  year =         2000,
  month =        sep,
  address =      "Montreal, Canada",
  pages =        "58--67",

  abstract = "In a language with non-parametric or ad-hoc
    polymorphism, it is possible to determine the identity of a type
    variable at run time.  With this facility, we can write a function
    to convert a term from one abstract type to another, if the two
    hidden types are identical.  However, the naive implementation of
    this function requires that the term be destructed and rebuilt. In
    this paper, we show how to eliminate this overhead using
    higher-order type abstraction. We demonstrate this solution in two
    frameworks for ad-hoc polymorphism: intensional type analysis and
    type classes.", 
  ps = dl # "cast/cast.ps",
  pdf = dl # "cast/cast.pdf"
  }

@InProceedings{crary00,
  plclub =       "yes",
  author =	 {Karl Crary and Stephanie Weirich},
  title =	 "Resource Bound Certification",
  booktitle =	 o27 # " " # popl,
  pages =	 {184--198},
  year =	 2000,
  address =	 "Boston, MA, USA",
  month =	 jan,
  pdf =          dl # "res/res.pdf",
  ps =          dl # "res/res.ps.gz",


  abstract = "Various code certification systems allow the
    certification and static verification of a variety of important
    safety properties such as memory safety and control-flow
    safety. These systems provide valuable tools for verifying that
    untrusted and potentially malicious code is safe before execution.
    However, one important safety property that is not usually
    included is that programs adhere to specific bounds on resource
    consumption, such as running time.

    We present a decidable type system capable of specifying and
    certifying bounds on resource consumption. Our system makes two
    advances over previous resource bound certification systems, both
    of which are necessary for a practical system: we allow the
    execution time of programs and their subroutines to vary,
    depending on their arguments, and we provide a fully automatic
    compiler generating certified executables from source-level
    programs. The principal device in our approach is a strategy for
    simulating dependent types using sum and inductive kinds. "
}

@inproceedings{morrisett+:talx86,
  plclub =       "yes",
  author =	 "Greg Morrisett and Karl Crary and Neal Glew and Dan
                  Grossman and Richard Samuels and Frederick Smith and
                  David Walker and Stephanie Weirich and Steve
                  Zdancewic",
  title =	 "{TALx86}: A Realistic Typed Assembly Language",
  booktitle =	 o2 # " " # wcsss,
  year =	 1999,
  month =	 may,
  pages =        "25--35",
  note =         "Published as {INRIA} research report number 0228, March 1999.",
  address =	 "Atlanta, GA, USA",
  ps =           tdl #  "talx86-wcsss.ps.gz",

  abstract = "The goal of typed assembly language (TAL) is to provide
     a low-level, statically typed target language that is better
     suited than Java bytecodes for supporting a wide variety of
     source languages and a number of important optimizations. In
     previous work, we formalized idealized versions of TAL and proved
     important safety properties about them. In this paper, we present
     our progress in defining and implementing a realistic typed
     assembly language called TALx86. The TALx86 instructions comprise
     a relatively complete fragment of the Intel IA32 (32-bit 80x86
     flat model) assembly language and are thus executable on
     processors such as the Intel Pentium. The type system for the
     language incorporates a number of advanced features necessary for
     safely compiling large programs to good code.

     To motivate the design of the type system, we demonstrate how
     various high-level language features are compiled to TALx86. For
     this purpose, we present a type-safe C-like language called
     Popcorn.",
}



## Not ready for distribution
@misc{crary+:lx-journal,
  author = 	  {Karl Crary and Stephanie Weirich},
  title = 	  {Flexible Type Analysis},
  note = 	  {28 pages},
  year = 	  {2004}
}

%   note = { An extended version of this paper is in
%   preparation.}
@inproceedings{crary+:lx,
  plclub =       "yes",
  author =	 "Karl Crary and Stephanie Weirich",
  title =	 "Flexible Type Analysis",
  booktitle =	 proc # o4 # icfp,
  year =	 1999,
  month =	 sep,
  address =	 "Paris, France",
  pages =	 "233--248",

  abstract = "Run-time type dispatch enables a variety of advanced
     optimization techniques for polymorphic languages, including
     tag-free garbage collection, unboxed function arguments, and
     flattened data structures.  However, modern type-preserving
     compilers transform types between stages of compilation, making
     type dispatch prohibitively complex at low levels of typed
     compilation. It is crucial therefore for type analysis at these
     low levels to refer to the types of previous
     stages. Unfortunately, no current intermediate language supports
     this facility.

     To fill this gap, we present the language LX, which provides a
     rich language of type constructors supporting type analysis
     (possibly of previous-stage types) as a programming idiom. This
     language is quite flexible, supporting a variety of other
     applications such as analysis of quantified types, analysis with
     incomplete type information, and type classes. We also show that
     LX is compatible with a type-erasure semantics.",

   ps  =      dl # "lx/lxpaper.ps.gz",
   pdf =      dl # "lx/lxpaper.pdf"
}


%  note =    "An extended and revised version of this paper is Journal Publication
%              \cite{crary+:intensional-journal}.", 
@InProceedings{crary+:intensional,
  plclub =       "yes",
  author = 	 {Karl Crary and Stephanie Weirich and Greg Morrisett},
  title = 	 "Intensional Polymorphism in Type Erasure Semantics",
  booktitle = 	 proc # o3 # icfp,
  year =	 1998,
  address =	 {Baltimore, MD, USA},
  month =	 sep,
  pages =   "301--313",                 
  ps = dl # "typepass/typepass.ps",
  pdf = dl # "typepass/typepass.pdf",

  abstract = { Intensional polymorphism, the ability to dispatch to
  different routines based on types at run time, enables a variety of
  advanced implementation techniques for polymorphic languages,
  including tag-free garbage collection, unboxed function arguments,
  polymorphic marshalling, and flattened data structures. To date,
  languages that support intensional polymorphism have required a
  type-passing (as opposed to type-erasure) interpretation where types
  are constructed and passed to polymorphic functions at run
  time. Unfortunately, type-passing suffers from a number of
  drawbacks; it requires duplication of constructs at the term and
  type levels, it prevents abstraction, and it severely complicates
  polymorphic closure conversion. We present a type-theoretic
  framework that supports intensional polymorphism, but avoids many of
  the disadvantages of type passing. In our approach, run-time type
  information is represented by ordinary terms. This avoids the
  duplication problem, allows us to recover abstraction, and avoids
  complications with closure conversion. In addition, our type system
  provides another improvement in expressiveness; it allows unknown
  types to be refined in place thereby avoiding certain
  beta-expansions required by other frameworks.  } }


#   note =     "This paper is superceded by \cite{crary+:intensional-journal}."
@TechReport{crary98a,
  author = 	 {Karl Crary and Stephanie Weirich and Greg Morrisett},
  title = 	 {Intensional Polymorphism in Type Erasure Semantics (Extended Version)},
  institution =  {Cornell University, Computer Science},
  year = 	 1998,
  number =	 {TR98-1721},
  month =	 nov,
  ps = dl # "typepass/typepass-tr.ps",
}

@TECHREPORT{HicksW00type-loading-tr,
  plclub =       "yes",
  AUTHOR = {Michael Hicks and Stephanie Weirich},
  TITLE = {A Calculus for Dynamic Loading},
  INSTITUTION = {University of Pennsylvania},
  YEAR = {2000},
  NUMBER = {MS-CIS-00-07},
  MONTH = {April},
  PDF = { http://www.cis.upenn.edu/~mwh/papers/loadcalc.pdf }
}

@incollection{hicks00,
  plclub =       "yes",
  author = "Michael Hicks and Stephanie Weirich and Karl Crary",
  title =  "Safe and Flexible Dynamic Linking of Native Code",
  booktitle = "Types in Compilation: Third International Workshop, TIC 2000;
               Montreal, Canada, September 21, 2000; Revised Selected Papers",
  editor = "R. Harper",
  publisher = "Springer", 
  year = 2001,
  series = lncs,
  volume = 2071, 
  pages = {147--176},
  note = "Related technical report: Michael Hicks and Stephanie
     Weirich.  A calculus for dynamic loading. 
    University of Pennsylvania Computer and Information Science
     Technical Report,
     MS-CIS-00-07,  April 2000.",

  abstract = "We present the design and implementation of the first
     complete framework for flexible and safe dynamic linking of
     native code. Our approach extends Typed Assembly Language with a
     primitive for loading and typechecking code, which is flexible
     enough to support a variety of linking strategies, but simple
     enough that it does not significantly expand the trusted
     computing base. Using this primitive, along with the ability to
     compute with types, we show that we can program many existing
     dynamic linking approaches. As a concrete demonstration, we have
     used our framework to implement dynamic linking for a type-safe
     dialect of C, closely modeled after the standard linking facility
     for Unix C programs. Aside from the unavoidable cost of
     verification, our implementation performs comparably with the
     standard, untyped approach.",

  url = "http://link.springer.de/link/service/series/0558/tocs/t2071.htm",
  ps = dl # "taldynlink/taldynlink.ps.gz",
  pdf = dl # "taldynlink/taldynlink.pdf"
  
}

@inproceedings{flanagan96, 
  plclub =       "yes",
   author = "Cormac Flanagan and Matthew Flatt and Shriram
             Krishnamurthi and Stephanie Weirich and Matthias
             Felleisen",
   title =  "Catching Bugs in the Web of Program Invariants",
   booktitle = proc # pldi,
   year = 1996,
   pages = "23--32",
   abstract = "MrSpidey is a user-friendly, interactive static
     debugger for Scheme. A static debugger supplements the standard
     debugger by analyzing the program and pinpointing those program
     operations tha may cause run-time errors suce as dereferencing
     the null pointer or applying non-functions. The program analysis
     of MrSpidey computes value set descriptions for each term in the
     program and constructs a value flow graph connecting the set
     descriptions. Using the set descriptions, MrSpidey can identify
     and highlight potentially erroneous program operations, whose
     cause the programmer can the explore by selectively exposing
     portions of the value flow graph.",

   PS = dl # "pldi96-ffkwf_ps.gz"
}

