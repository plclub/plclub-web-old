@COMMENT{{This file has been generated by bib2bib 1.75}}

@COMMENT{{Command line: /usr/bin/bib2bib MS-CIS-03-26.bib MS-CIS-04-26.bib MS-CIS-05-04.bib MS-CIS-05-05.bib MS-CIS-05-07.bib gadt.bib icfp2003-corrected.bib icfp2003.bib icfp2005.bib itrs2002.bib lics2005.bib poplmark.bib senior-thesis.bib tldi2005.bib tr-717-04.bib -ob /home/geoffw/svnroot/web/dest-official/research/papers/geoffw.bib}}

@TECHREPORT{Was+Wei:UPTR-2003,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Boxes Go Bananas: Encoding higher-order abstract syntax with 
           parametric polymorphism (Extended Version)},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall, 
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2003,
  NUMBER = {MS-CIS-03-26},
  MONTH = {September},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-03-26.pdf},
  PLCLUB = {yes},
  ABSTRACT = {
Higher-order abstract syntax is a simple technique for implementing
languages with functional programming.  Object variables and binders
are implemented by variables and binders in the host language.  By
using this technique, one can avoid implementing common and tricky
routines dealing with variables, such as capture-avoiding
substitution.  However, despite the advantages this technique
provides, it is not commonly used because it is difficult to write
sound elimination forms (such as folds or catamorphisms) for
higher-order abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.

In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals.  From
this implementation, we derive ``fusion laws'' that functional
programmers may use to reason about the iteration operator.  Finally,
we show how this use of parametric polymorphism corresponds to the
Sch\"urmann, Despeyroux and Pfenning method of enforcing
parametricity through modal types. We do so by using this library to
give a sound and complete encoding of their calculus into System
$\mathrm{F}_{\omega}$.  This encoding can serve as a starting point
for reasoning about higher-order structures in polymorphic languages.}
}

@TECHREPORT{Vyt+Was+Wei:UPTR-2004,
  AUTHOR = {Dimitrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich},
  TITLE = {An Open and Shut Typecase (Extended Version)},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall, 
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2004,
  NUMBER = {MS-CIS-04-26},
  MONTH = {November},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-04-26.pdf},
  PLCLUB = {yes},
  ABSTRACT = {
Ad-hoc polymorphism is a compelling addition to typed programming
languages.  There are two different forms of ad-hoc polymorphism. With
the nominal form, the execution of an operation is determined solely
by the name of the type argument, whereas with the structural form,
operations are defined by case analysis on the structure of types.
The two forms differ in the way that they treat user-defined types.
Operations defined by the nominal approach are considered ``open''---the
programmer can add cases for new types without modifying existing
code. The operations must be extended however with specialized code for
the new types, and it may be tedious and even difficult to add extensions
that apply to a potentially large universe of user-defined types.
Structurally defined operations apply to new types by treating them as
equal to their underlying definitions, so no new cases for new types
are necessary. However this form is considered ``closed'' to extension,
as the behaviour of the operations cannot be differentiated for the
new types. This form destroys the distinctions that user-defined types
are designed to express.  Both approaches have their benefits, so it
is important to provide both capabilities in a single language that is
expressive enough to decouple the ``openness'' issue from the way that
user-defined types are treated. We present such a language that supports
both forms of ad-hoc polymorphism.
  }
}

@TECHREPORT{Was+Wei:UPTR-2005,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Generalizing Parametricity Using Information Flow (Extended Version)},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall, 
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2005,
  NUMBER = {MS-CIS-05-04},
  MONTH = {June},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-04.pdf},
  PLCLUB = {yes},
  ABSTRACT = {
Run-time type analysis allows programmers to easily and concisely define
operations based upon type structure, such as serialization, iterators,
and structural equality.  However, when types can be inspected at run
time, nothing is secret.  A module writer cannot use type abstraction
to hide implementation details from clients: clients can determine the
structure of these supposedly ``abstract'' data types.  Furthermore,
access control mechanisms do not help isolate the implementation of
abstract datatypes from their clients.  Buggy or malicious authorized
modules may leak type information to unauthorized clients, so module
implementors cannot reliably tell which parts of a program rely on their
type definitions.

Currently, module implementors rely on parametric polymorphism to provide
integrity and confidentiality guarantees about their abstract datatypes.
However, standard parametricity does not hold for languages with run-time
type analysis; this paper shows how to generalize parametricity so
that it does.   The key is to augment the type system with annotations
about information-flow.  Implementors can then easily see which parts
of a program depend on the chosen implementation by tracking the flow
of dynamic type information.}
}

@TECHREPORT{Was:UPTR-2005,
  AUTHOR = {Geoffrey Washburn},
  TITLE = {Cause and Effect: Type Systems for Effects and Dependencies},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall, 
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2005,
  NUMBER = {MS-CIS-05-05},
  MONTH = {July},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-05.pdf},
  PLCLUB = {yes},
  ABSTRACT = {
Frameworks for formal reasoning about programs are important not only
for automated tools but also for programmers.   Type systems are a
popular framework both for documenting program interfaces and for
developing static analysis tools.  However, type systems commonly
used in practice today fail to capture essential aspects of program
behavior: The effects and dependencies of the programs.  In this paper,
we examine a prototypical effect type system in the style of Gifford
et al. and a canonical example of a dependency type system based upon
the work of Zdancewic.  Finally, we show how these two type systems
can be embedded in a more general framework, a monadic type system as
developed by Pfenning and Davies.      
  }
}

@TECHREPORT{Dan+Wal+Was+Wei:UPTR-2005,
  AUTHOR = {Daniel S. Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Poly{AML}: A Polymorphic Aspect-oriented Functional Programmming Language (Extended Version)},
  INSTITUTION = {University of Pennsylvania},
  ADDRESS = {Computer and Information Science Department, Levine Hall,
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
  YEAR = 2005,
  NUMBER = {MS-CIS-05-07},
  PLCLUB = {yes},
  MONTH = {May},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-07.pdf},
  ABSTRACT = {
This paper defines PolyAML, a typed functional, aspect-oriented
programming language.  The main contribution of PolyAML is the
seamless integration of polymorphism, run-time type analysis and
aspect-oriented programming language features.  In particular, PolyAML
allows programmers to define type-safe polymorphic advice using pointcuts
constructed from a collection of polymorphic join points.  PolyAML
also comes equipped with a type inference algorithm that conservatively
extends Hindley-Milner type inference.  To support first-class
polymorphic point-cut designators, a crucial feature for developing
aspect-oriented profiling or logging libraries, the algorithm blends the
conventional Hindley-Milner type inference algorithm with a simple form
of local type inference.

We give our language operational meaning via a type-directed translation
into an expressive type-safe intermediate language.  Many complexities
of the source language are eliminated in this translation, leading
to a modular specification of its semantics.  One of the novelties
of the intermediate language is the definition of polymorphic labels
for marking control-flow points.  These labels are organized in a tree
structure such that a parent in the tree serves as a representative for
all of its children.  Type safety requires that the type
of each child is less polymorphic than its parent type.  Similarly,
when a set of labels is assembled as a pointcut, the type of each label
is an instance of the type of the pointcut.
}
}

@MISC{Jon+Was+Wei:2004,
  AUTHOR = {Simon Peyton Jones and Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Wobbly types: type inference for generalised algebraic data types},
  YEAR = 2004,
  MONTH = {July},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/gadt.pdf},
  PLCLUB = {yes},
  NOTE = {Unpublished},
  ABSTRACT = {
Generalised algebraic data types (GADTs), sometimes known as ``guarded
recursive data types'' or ``first-class phantom types'', are a simple
but powerful generalisation of the data types of Haskell and ML.
Recent works have given compelling examples of the utility of GADTs,
although type inference is known to be difficult.

It is time to pluck the fruit.  Can GADTs be added to Haskell, without
losing type inference, or requiring unacceptably heavy type annotations?
Can this be done without completely rewriting the already-complex Haskell
type-inference engine, and without complex interactions with (say)
type classes?  We answer these questions in the affirmative, giving
a type system that explains just what type annotations are required,
and a prototype implementation that implements it.  Our main technical
innovation is \emph{wobbly types}, which express in a declarative way
the uncertainty caused by the incremental nature of typical type-inference
algorithms.      
  }
}

@INPROCEEDINGS{Was+Wei:ICFP-2003a,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Boxes Go Bananas: Encoding higher-order abstract syntax with 
           parametric polymorphism},
  BOOKTITLE = {Proceedings of the Eighth {ACM SIGPLAN} International 
               Conference on Functional Programming},
  YEAR = 2003,
  MONTH = {August},
  ADDRESS = {Uppsala, Sweden},
  ORGANIZATION = {ACM SIGPLAN},
  PAGES = {249--262},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/ifcp2004-corrected.pdf},
  PLCLUB = {yes},
  ABSTRACT = {
Higher-order abstract syntax is a simple technique for implementing
languages with functional programming.  Object variables and binders
are implemented by variables and binders in the host language.  By
using this technique, one can avoid implementing common and tricky
routines dealing with variables, such as capture-avoiding
substitution.  However, despite the advantages this technique
provides, it is not commonly used because it is difficult to write
sound elimination forms (such as folds or catamorphisms) for
higher-order abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.

In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals.  From
this implementation, we derive ``fusion laws'' that functional
programmers may use to reason about the iteration operator.  Finally,
we show how this use of parametric polymorphism corresponds to the
Sch\"{u}rmann, Despeyroux and Pfenning method of enforcing
parametricity through modal types. We do so by using this library to
give a sound and complete encoding of their calculus into System
$\mathrm{F}_{\omega}$.  This encoding can serve as a starting point
for reasoning about higher-order structures in polymorphic languages.},
  NOTE = {
This version fixes a number of typographical errors found in the ICFP 2003     
document; there are no signficant technical changes.  Generated September 2003.}
}

@INPROCEEDINGS{Was+Wei:ICFP-2003,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Boxes Go Bananas: Encoding higher-order abstract syntax with 
           parametric polymorphism},
  BOOKTITLE = {Proceedings of the Eighth {ACM SIGPLAN} International 
               Conference on Functional Programming},
  YEAR = 2003,
  MONTH = {August},
  ADDRESS = {Uppsala, Sweden},
  ORGANIZATION = {ACM SIGPLAN},
  PAGES = {249--262},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/icfp2003.pdf},
  PLCLUB = {yes},
  ABSTRACT = {
Higher-order abstract syntax is a simple technique for implementing
languages with functional programming.  Object variables and binders
are implemented by variables and binders in the host language.  By
using this technique, one can avoid implementing common and tricky
routines dealing with variables, such as capture-avoiding
substitution.  However, despite the advantages this technique
provides, it is not commonly used because it is difficult to write
sound elimination forms (such as folds or catamorphisms) for
higher-order abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.

In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals.  From
this implementation, we derive ``fusion laws'' that functional
programmers may use to reason about the iteration operator.  Finally,
we show how this use of parametric polymorphism corresponds to the
Sch\"{u}rmann, Despeyroux and Pfenning method of enforcing
parametricity through modal types. We do so by using this library to
give a sound and complete encoding of their calculus into System
$\mathrm{F}_{\omega}$.  This encoding can serve as a starting point
for reasoning about higher-order structures in polymorphic languages.}
}

@INPROCEEDINGS{{Dan+Wal+Was+Wei:2005,
  AUTHOR = {Daniel S. Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Poly{AML}: A Polymorphic Aspect-oriented Functional Programmming Language},
  BOOKTITLE = {Proceedings of the Tenth {ACM SIGPLAN} International
               Conference on Functional Programming},
  YEAR = 2005,
  MONTH = {September},
  ADDRESS = {Tallinn, Estonia},
  ORGANIZATION = {ACM SIGPLAN},
  PLCLUB = {yes},
  ABSTRACT = {
This paper defines PolyAML, a typed functional, aspect-oriented
programming language.  The main contribution of PolyAML is the
seamless integration of polymorphism, run-time type analysis and
aspect-oriented programming language features.  In particular, PolyAML
allows programmers to define type-safe polymorphic advice using pointcuts
constructed from a collection of polymorphic join points.  PolyAML
also comes equipped with a type inference algorithm that conservatively
extends Hindley-Milner type inference.  To support first-class
polymorphic point-cut designators, a crucial feature for developing
aspect-oriented profiling or logging libraries, the algorithm blends the
conventional Hindley-Milner type inference algorithm with a simple form
of local type inference.

We give our language operational meaning via a type-directed translation
into an expressive type-safe intermediate language.  Many complexities
of the source language are eliminated in this translation, leading
to a modular specification of its semantics.  One of the novelties
of the intermediate language is the definition of polymorphic labels
for marking control-flow points.  These labels are organized in a tree
structure such that a parent in the tree serves as a representative for
all of its children.  Type safety requires that the type
of each child is less polymorphic than its parent type.  Similarly,
when a set of labels is assembled as a pointcut, the type of each label
is an instance of the type of the pointcut.
  }
}

@INPROCEEDINGS{Kfo+Was+Wel:ITRS-2002,
  ITRSPAPER = {yes},
  AUTHOR = {Assaf J. Kfoury and Geoff Washburn and J. B. Wells},
  TITLE = {Implementing Compositional Analysis Using
                  Intersection Types With Expansion Variables},
  DARTREPORT = {yes},
  CHURCHREPORT = {yes},
  YEAR = {2002},
  DVI = {http://www.church-project.org/reports/electronic/Kfo+Was+Wel:ITRS-2002.dvi},
  PDF = {http://www.church-project.org/reports/electronic/Kfo+Was+Wel:ITRS-2002.pdf},
  ELSEVIERURLB = {http://www.elsevier.nl/gej-ng/31/29/23/125/51/show/Products/notes/index.htt},
  ELSEVIERURLA = {http://www.elsevier.nl/locate/entcs/volume70.html},
  ABSTRACT = {A program analysis is \emph{compositional} when the analysis
result for a particular program fragment is obtained solely from the
results for its immediate subfragments via some composition operator.  This
means the subfragments can be analyzed independently in any order.  Many
commonly used program analysis techniques (in particular, most abstract
interpretations and most uses of the Hindley/Milner type system) are not
compositional and require the entire text of a program for sound and
complete analysis.  \par System I is a recent type system for the pure
$\lambda$-calculus with intersection types and the new technology of
expansion variables.  System I supports compositional analysis because it
has the \emph{principal typings} property and an algorithm based on the new
technology of $\beta$-unification has been developed that finds these
principal typings.  In addition, for each natural number $k$, typability in
the rank-$k$ restriction of System I is decidable, so a complete and
terminating analysis algorithm exists for the rank-$k$ restriction.  \par
This paper presents new understanding that has been gained from working
with multiple implementations of System I and $\beta$-unification-based
analysis algorithms.  The previous literature on System I presented the
type system in a way that helped in proving its more important theoretical
properties, but was not as easy for implementers to follow as it could be.
This paper provides a presentation of many aspects of System I that should
be clearer as well as a discussion of important implementation issues.}
}

@INPROCEEDINGS{Was+Wei:2005,
  AUTHOR = {Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Generalizing Parametricity Using Information Flow},
  BOOKTITLE = {The Twentieth Annual IEEE Symposium on Logic in Computer Science (LICS 2005)},
  YEAR = 2005,
  MONTH = {June},
  PAGES = {62--71},
  ADDRESS = {Chicago, IL},
  ORGANIZATION = {IEEE Computer Society},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/lics2005.pdf},
  PLCLUB = {yes},
  ABSTRACT = {
Run-time type analysis allows programmers to easily and concisely define
operations based upon type structure, such as serialization, iterators,
and structural equality.  However, when types can be inspected at run
time, nothing is secret.  A module writer cannot use type abstraction
to hide implementation details from clients: clients can determine the
structure of these supposedly ``abstract'' data types.  Furthermore,
access control mechanisms do not help isolate the implementation of
abstract datatypes from their clients.  Buggy or malicious authorized
modules may leak type information to unauthorized clients, so module
implementors cannot reliably tell which parts of a program rely on their
type definitions.

Currently, module implementors rely on parametric polymorphism to provide
integrity and confidentiality guarantees about their abstract datatypes.
However, standard parametricity does not hold for languages with run-time
type analysis; this paper shows how to generalize parametricity so
that it does.   The key is to augment the type system with annotations
about information-flow.  Implementors can then easily see which parts
of a program depend on the chosen implementation by tracking the flow
of dynamic type information.
  }
}

@INPROCEEDINGS{POPLmark:2005,
  AUTHOR = {Brian E. Aydemir and Aaron Bohannon and Matthew Fairbairn and 
            J. Nathan Foster and Benjamin C. Pierce and Peter Sewell and
            Dimitrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich
            and Steve Zdancewic},
  TITLE = {Mechanized metatheory for the masses: The POPLmark Challenge},
  BOOKTITLE = {The Eighteenth International Conference on Theorem Proving in Higher Order Logics (TPHOLs 2005)},
  YEAR = 2005,
  MONTH = {August},
  ADDRESS = {Oxford, England},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/poplmark.pdf},
  PLCLUB = {yes},
  ABSTRACT = {
How close are we to a world where every paper on programming languages is
accompanied by an electronic appendix with machine-checked proofs?

We propose an initial set of benchmarks for measuring progress in this
area.  Based on the metatheory of System F_{<:}, a typed lambda-calculus
with second-order polymorphism, subtyping, and records, these benchmarks
embody many aspects of programming languages that are challenging to
formalize: variable binding at both the term and type levels, syntactic
forms with variable numbers of components (including binders), and
proofs demanding complex induction principles.
We hope that these benchmarks will help clarify the current state of the
art, provide a basis for comparing competing technologies, and motivate
further research.            
  }
}

@MISC{Was:Senior-Thesis,
  AUTHOR = {Geoffrey Washburn},
  TITLE = {Modal Typing for Specifying Run-time Code Generation},
  SCHOOL = {Carnegie Mellon University},
  MONTH = {May},
  YEAR = {2001},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/senior-thesis.pdf}
}

@INPROCEEDINGS{Vyt+Was+Wei:TLDI-2005,
  AUTHOR = { Dimitrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich },
  TITLE = { An Open and Shut Typecase },
  BOOKTITLE = { The Second {ACM SIGPLAN} Workshop on Types in Language Design and Implementation },
  YEAR = 2005,
  MONTH = {January},
  ADDRESS = {Longbeach, California},
  PAGES = {13--24},
  ORGANIZATION = {ACM SIGPLAN},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/tldi2005.pdf},
  PLCLUB = {yes},
  ABSTRACT = {
Two different ways of defining ad-hoc polymorphic operations commonly occur in
programming languages. With the first form polymorphic operations are defined
inductively on the structure of types while with the second form polymorphic
operations are defined for specific sets of types.

In intensional type analysis operations are defined by induction on the
structure of types. Therefore no new cases are necessary for user-defined types,
because these types are equivalent to their underlying structure.
However, intensional type analysis is ``closed'' to extension, as the behavior
of the operations cannot be differentiated for the new types, thus destroying
the distinctions that these types are designed to express.

Haskell type classes on the other hand define polymorphic operations for sets
of types. Operations defined by class instances are considered ``open''---the
programmer can add instances for new types without modifying existing code. However,
the operations must be extended with specialized code for each new type, and it
may be tedious or even impossible to add extensions that apply to a large
universe of new types.

Both approaches have their benefits, so it is important to let
programmers decide which is most appropriate for their needs. In this
paper, we define a language that supports both forms of ad-hoc
polymorphism, using the same basic constructs.
}
}

@TECHREPORT{Dan+Wal+Was+Wei:PTR-2004,
  AUTHOR = {Daniel S. Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  TITLE = {Analyzing polymorphic advice},
  INSTITUTION = {Princeton University},
  ADDRESS = {Department of Computer Science, Princeton University, 
             35 Olden Street, Princeton, NJ 08544 },
  YEAR = 2004,
  NUMBER = {TR-717-04},
  MONTH = {December},
  PDF = {http://www.cis.upenn.edu/~geoffw/research/papers/tr-717-04.pdf},
  PLCLUB = {yes},
  ABSTRACT = {
We take one of the first steps towards developing a practical,
statically-typed, functional, aspect-oriented programming language
by showing how to integrate polymorphism and type analysis with
aspect-oriented programming features.  In particular, we demonstrate
how to define type-safe polymorphic advice using pointcuts that unify
a collection of polymorphic join points.  We also introduce a new
mechanism for specifying context-sensitive advice that involves pattern
matching against the current stack of activation records, and meshes
well with functional programming idioms.  We give our language meaning
via a type-directed translation into an expressive, but fairly simple,
type-safe intermediate language.  Many complexities of the source language
are eliminated in this translation, leading to a modular specification
of its semantics.  One of the novelties of the intermediate language is
the definition of polymorphic labels for marking control-flow points.
These labels are organized in a tree structure such that a parent in the
tree serves as a representative for the collection of all its children.
Type safety requires that the type of each child is a generic instance
of the type of the polymorphic parent.  Similarly, when a set of labels
is assembled as a pointcut, the type of each label is an instance of
the type of the pointcut.
  }
}

