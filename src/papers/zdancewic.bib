@STRING{sosp18	= "Proc. 18th {ACM} Symp. on Operating System Principles (SOSP)" }
@STRING{esop10	= "Proc. of the 10th European Symposium on Programming" }
@STRING{esop14	= "Proc. of the 14th European Symposium on Programming" }
@STRING{ieee	= "{IEEE} Computer Society Press" }
@STRING{entcs	= {Electronic Notes in Theoretical Computer Science} }
@STRING{popl32	= "Proc. 32nd {ACM} Symp. on Principles of Programming
		  Languages (POPL)" }
@STRING{lncs    = "Lecture Notes in Computer Science"}




@InProceedings{Zda04,
  author = 	 {Steve Zdancewic},
  title = 	 {\textbf{Challenges for Information-flow Security}},
  booktitle =	 {Proceedings of the 1st International Workshop on the
  Programming Language Interference and Dependence (PLID'04)},
  year =	 2004,
  hinvited =     "yes",
  plclub   =     "yes",
  pdf      =     "http://www.cis.upenn.edu/~stevez/papers/Zda04.pdf"
}

@InProceedings{Zda03,
  author = 	 {Steve Zdancewic},
  title = 	 {\textbf{A Type System for Robust Declassification}},
  booktitle =	 {Proceedings of the Nineteenth Conference on the 
                  Mathematical Foundations of Programming Semantics},
  year =	 2003,
  month =	 mar,
  publisher =	 entcs,
  hinvited =     "yes",
  plclub =       "yes",
  ps =           "http://www.cis.upenn.edu/~stevez/papers/Zda03.ps",
  pdf =          "http://www.cis.upenn.edu/~stevez/papers/Zda03.pdf",
  abstract =     "Language-based approaches to information security have led to the
  development of \emph{security type systems\/} that permit the
  programmer to describe confidentiality policies on data.  Security
  type systems are usually intended to enforce \emph{noninterference},
  a property that requires that high-security information not affect
  low-security computation.  However, in practice, noninterference is
  often too restrictive---the desired policy does permit some
  information leakage.

  
  To compensate for the strictness of noninterference, practical
  approaches include some mechanism for \emph{declassifying}
  high-security information.  But such declassification is potentially
  dangerous, and its use should be restricted to prevent unintended
  information leaks. Zdancewic and Myers previously introduced the
  notion of \emph{robust declassification\/} in an attempt to capture
  the desired restrictions on declassification, but that work did not
  propose a method for determining when a program satisfies the 
  robust declassification condition.


  This paper motivates robust declassification and shows that a simple
  change to a security type system can enforce it.  The idea is to
  extend the lattice of security labels to include \emph{integrity}
  constraints as well as confidentiality constraints and then require
  that the decision to perform a declassification have high
  integrity."
}


@Article{	  ZM02,
  author	= "Steve Zdancewic and Andrew C. Myers",
  title		= "\textbf{Secure Information Flow via Linear Continuations}",
  journal	= "Higher Order and Symbolic Computation",
  volume	= 15,
  number	= "2/3",
  year		= 2002,
  hjournal      = "yes",
  plclub        = "yes",
  ps            = "http://www.cis.upenn.edu/~stevez/papers/ZM02.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/ZM02.pdf",
  abstract      = "\emph{Security-typed languages} enforce secrecy or integrity policies by
type-checking.  This paper investigates continuation-passing style (CPS) as a
means of proving that such languages enforce noninterference and as a first
step towards understanding their compilation.  We present a low-level, secure
calculus with higher-order, imperative features and \emph{linear
continuations}.


Linear continuations impose a stack discipline on the control flow of
programs.  This additional structure in the type system lets us establish a
strong information-flow security property called \emph{noninterference}.  We prove
that our CPS target language enjoys the noninterference property and we show
how to translate secure high-level programs to this low-level
language.  This noninterference proof is the first of its kind for a
language with higher-order functions and state."
}

@Article{	  ZZNM02,
  author	= {Steve Zdancewic and Lantian Zheng and Nathaniel Nystrom
		  and Andrew C. Myers},
  title		= {\textbf{Secure Program Partitioning}},
  journal	= {Transactions on Computer Systems},
  year		= 2002,
  volume        = 20,
  number        = 3,
  pages         = {283--328},
  hjournal      = "yes",
  plclub        = "yes",
  ps            = "http://www.cis.upenn.edu/~stevez/papers/ZZNM02.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/ZZNM02.pdf",
  abstract      = "This paper presents secure program partitioning, a language-based
technique for protecting confidential data during computation in
distributed systems containing mutually untrusted hosts. Confidentiality
and integrity policies can be expressed by annotating programs with
security types that constrain information flow; these programs can then
be partitioned automatically to run securely on heterogeneously trusted
hosts. The resulting communicating subprograms collectively implement
the original program, yet the system as a whole satisfies the security
requirements of participating principals without requiring a universally
trusted host machine.  The experience in applying this methodology and
the performance of the resulting distributed code suggest that this is a
promising way to obtain secure distributed computation.


This article is an expanded version of the published paper ``Untrusted
Hosts and Confidentiality: Secure Program Partitioning''.
The main difference between the two is Appendix A, which
contains a correctness proof for the control-transfer protocols described
in Section 5."
}

@Article{	  GMZ00,
  author	= "Dan Grossman and Greg Morrisett and Steve Zdancewic",
  title		= {\textbf{Syntactic Type Abstraction}},
  journal	= {Transactions on Programming Languages and Systems},
  year		= 2000,
  volume	= 22,
  number	= 6,
  pages		= {1037--1080},
  month		= nov,
  hjournal      = "yes",
  plclub        = "yes",
  ps            = "http://www.cis.upenn.edu/~stevez/papers/GMZ00.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/GMZ00.pdf",

  abstract = "Software developers often structure programs in such a
way that different pieces of code constitute distinct
principals. Types help define the protocol by which these principals
interact. In particular, abstract types allow a principal to make
strong assumptions about how well-typed clients use the facilities
that it provides. We show how the notions of principals and type
abstraction can be formalized within a language. Different principals
can know the implementation of different abstract types. We use
additional syntax to track the flow of values with abstract types
during the evaluation of a program and demonstrate how this framework
supports syntactic proofs (in the style of subject reduction) for
type-abstraction properties. Such properties have traditionally
required semantic arguments; using syntax avoids the need to build a
model for the language. We present various typed lambda calculi with
principals, including versions that have mutable state and recursive types."
}


@InProceedings{TZ04b,
  author = 	 {Stephen Tse and Steve Zdancewic},
  title = 	 {\textbf{Translating Dependency into Parametricity}},
  booktitle =	 {Proc. of the 9th ACM SIGPLAN International Conference on
		  Functional Programming},
  year =	 2004,
  hconf        = "yes",
  plclub        = "yes",
  ps =           "http://www.cis.upenn.edu/~stevez/papers/TZ04b.ps",
  pdf =          "http://www.cis.upenn.edu/~stevez/papers/TZ04b.pdf",
  abstract = "
  The \textit{dependency core calculus} (DCC) was introduced by Abadi
  et al. as a unifying formal framework in which to study a variety of
  important program analyses including binding-time, information-flow,
  slicing, and function call tracking. The novel feature of DCC is a
  lattice of monads and a nonstandard typing rule for their associated
  \texttt{bind} operations.  Intuitively, the lattice structure describes
  which computations in a program may depend on each other.  Abadi et
  al.  prove a \textit{noninterference} result that establishes the
  correctness of DCC's type system, and they use that result to show
  that type systems for the above-mentioned analyses are correct.
  

  In this paper, we study the relationship between DCC and the
  Girard--Reynolds polymorphic lambda calculus (System F).  In
  particular, we show how to encode the recursion-free fragment of DCC
  into F via a type-directed translation.  The main theorem we present
  uses this translation to derive the noninterference result for DCC
  from the standard parametricity theorem of System F.  In addition to
  providing insight into DCC's type system, the hope is that the
  translation presented here may yield implementation strategies for
  non-standard type systems (e.g. for information flow security) in
  languages that have parametric polymorphism.
  "
}

@InProceedings{MSZ04,
  author = 	 {Andrew C. Myers and Andrei Sabelfeld and Steve Zdancewic},
  title = 	 {\textbf{Enforcing Robust Declassification}},
  booktitle =	 "Proc. of 17th IEEE Computer Security Foundations Workshop",
  pages =	 "172--186",
  year =	 2004,
  address =	 "Asilomar, CA",
  month =	 jun,
  publisher =	 ieee,
  hconf        = "yes",
  plclub        = "yes",
  pdf =          "http://www.cis.upenn.edu/~stevez/papers/MSZ04.pdf",
  abstract =     "
    Noninterference requires that there
  is no information flow from sensitive to public data in a given
  system. However, many systems perform
  intentional release of sensitive information as part of their
  correct functioning and therefore violate noninterference.
  To control information flow while permitting intentional
  information release, some systems have a downgrading or
  declassification mechanism. A major danger of such a mechanism is
  that it may cause unintentional information release.
  This paper shows that a robustness property
  can be used to characterize programs in which declassification mechanisms
  cannot be exploited by attackers to release more information than
  intended. It describes a simple way to provably enforce this robustness
  property through a type-based compile-time program analysis. The paper also
  presents a generalization of robustness that
  supports upgrading (endorsing) data integrity.
  "
}






@InProceedings{TZ05a,
  author = 	 {Stephen Tse and Steve Zdancewic},
  title = 	 {\textbf{Designing a Security-typed Language with Certificate-based Declassification}},
  booktitle =	 esop14,
  year = 	 2005,
  note =	 {To appear},
  hconf =        "yes",
  plclub        = "yes",
  pdf   =        "http://www.cis.upenn.edu/~stevez/papers/TZ05a.pdf",
  abstract = 
  "This paper presents a calculus that supports information-flow
  security policies and certificate-based declassification. The
  decentralized label model and its downgrading mechanisms are
  concisely expressed in the polymorphic lambda calculus with
  subtyping (System F-Sub).  We prove a conditioned version of the
  noninterference theorem such that authorization for declassification
  is justified by digital certificates from public-key
  infrastructures."
}


@InProceedings{LZ05b,
  author = 	 {Peng Li and Steve Zdancewic},
  title = 	 {\textbf{Practical Information-flow Control in Web-based Information Systems}},
  booktitle =	 "Proc. of 18th IEEE Computer Security Foundations Workshop",
  year =	 2005,
  note =	 "To appear",
  hconf =        "yes",
  plclub        = "yes",
  pdf =          "http://www.cis.upenn.edu/~stevez/papers/LZ05b.pdf",
}

@InProceedings{LZ05,
  author = 	 {Peng Li and Steve Zdancewic},
  title = 	 {\textbf{Downgrading Policies and Relaxed Noninterference}},
  booktitle =	 popl32,
  year =	 2005,
  pages =        "158--170",
  month =        jan,
  hconf =        "yes",
  plclub        = "yes",
  pdf   =        "http://www.cis.upenn.edu/~stevez/papers/LZ05a.pdf",

  abstract = " In traditional information-flow type systems, the
    security policy is often formalized as noninterference properties.
    However, noninterference alone is too strong to express security
    properties useful in practice.  If we allow downgrading in such
    systems, it is challenging to formalize the security policy as an
    extensional property of the system.


    This paper presents a generalized framework of downgrading
  policies.  Such policies can be specified in a simple and tracable
  language and can be statically enforced by mechanisms such as type
  systems.  The security guarantee is then formalized as a concise
  extensional property using program equivalences.  This
  \textit{relaxed noninterference} generalizes traditional pure
  noninterference and precisely characterizes the information released
  due to downgrading.  
" }

@InProceedings{LZ04a,
  author = 	 {Peng Li and Steve Zdancewic},
  title = 	 {\textbf{Advanced Control Flow in Java Card Programming}},
  booktitle =	 {Proceedings of the 2004 ACM SIGPLAN/SIGBED Conference on Languages, 
                  Compilers, and Tools for Embedded Systems},
  pages =	 "165--174",
  year =	 2004,
  month =	 jun,
  hconf        = "yes",
  plclub        = "yes",
  pdf       =    "http://www.cis.upenn.edu/~stevez/papers/LZ04a.pdf",
  abstract =     "
Java Card technology simplifies the development of smart card
applications by providing a high-level programming language similar to
Java.  However, the master-slave programming model used in current
Java Card platform creates control flow difficulties when writing
complex card programs, making it inconvenient, tedious, and
error-prone to implement Java Card applications. This paper examines
these drawbacks of the master-slave model and proposes a concurrent
thread model for developing future Java Card programs, which is much
closer to conventional Java network programming.  This paper also
presents a code translation algorithm and a corresponding tool that
makes it possible to write card programs in the concurrent thread
model without losing compatibility with the existing Java Card API.
"
}

@InProceedings{TZ04a,
  author = 	 {Stephen Tse and Steve Zdancewic},
  title = 	 {\textbf{Run-time Principals in Information-flow Type Systems}},
  booktitle =	 {IEEE 2004 Symposium on Security and Privacy},
  year =	 2004,
  month =	 may,
  publisher =	 ieee,
  hconf        = "yes",
  plclub        = "yes",
  ps        =    "http://www.cis.upenn.edu/~stevez/papers/TZ04a.ps",
  pdf       =    "http://www.cis.upenn.edu/~stevez/papers/TZ04a.pdf",
  abstract =     "
  Information-flow type systems are a promising approach for enforcing
  strong end-to-end confidentiality and integrity policies. Such
  policies, however, are usually specified in term of static
  information--data is labeled \textit{high} or \textit{low} security at
  compile time.  In practice, the confidentiality of data may depend
  on information available only while the system is running
  

  This paper studies language support for \textit{run-time principals}, a
  mechanism for specifying information-flow security policies that
  depend on which principals interact with the system.  We establish
  the basic property of noninterference for programs written in such
  language, and use run-time principals for specifying run-time
  authority in downgrading mechanisms such as declassification.
  

  In addition to allowing more expressive security policies, run-time
  principals enable the integration of language-based security
  mechanisms with other existing approaches such as Java stack
  inspection and public key infrastructures. We sketch an
  implementation of run-time principals via public keys such that
  principal delegation is verified by certificate chains.
  " 
}

@InProceedings{LMZ03,
  author = 	 {Peng Li and Yun Mao and Steve Zdancewic},
  title = 	 {\textbf{Information Integrity Policies}},
  booktitle =	 {Proceedings of the Workshop on Formal Aspects in Security \& Trust (FAST)},
  year =	 2003,
  month =        sep,
  hconf        = "yes",
  plclub        = "yes",
  ps =           "http://www.cis.upenn.edu/~stevez/papers/LMZ03.ps",
  pdf =          "http://www.cis.upenn.edu/~stevez/papers/LMZ03.pdf",
  abstract =     "Information integrity policies are traditionally enforced by
  access control mechanisms that prevent unauthorized users from
  modifying data.  However, access control does not provide end-to-end
  assurance of integrity.  For that reason, integrity guarantees in
  the form of noninterference assertions have been proposed.  Despite
  the appeals of such information-flow based approaches to integrity,
  that solution is also unsatisfactory because it leads to a weaker
  notion of integrity than needed in practice.
  

  This paper attempts to clarify integrity policies by
  comparing and contrasting access control vs. information flow,
  integrity vs. confidentiality policies, and
  integrity vs. availability policies.  The paper also examines data
  invariants as a way to strengthen integrity.  The result is a better
  classification of information-integrity policies."
}

@InProceedings{WZL03,
  author = 	 {David Walker and Steve Zdancewic and Jay Ligatti},
  title = 	 {\textbf{A Theory of Aspects}},
  booktitle =	 {Proc. of the 8th ACM SIGPLAN International Conference on
		  Functional Programming},
  year =	 2003,
  address =	 {Upsala, Sweden},
  month =	 aug,
  hconf        = "yes",
  plclub        = "yes",
  ps =           "http://www.cis.upenn.edu/~stevez/papers/WZL03.ps",
  pdf =          "http://www.cis.upenn.edu/~stevez/papers/WZL03.pdf",
  abstract =     "This paper define the semantics of MinAML, an idealized
aspect-oriented programming language, by giving 
a type-directed translation from its user-friendly external language
to its compact, well-defined core language.
We argue that our framework is an effective way
to give semantics to aspect-oriented programming languages in
general because the translation eliminates shallow syntactic differences
between related constructs and permits definition of a clean,
easy-to-understand, and easy-to-reason-about core language.


The core language extends the simply-typed lambda
calculus with two central new abstractions: explicitly labeled program
points and first-class advice.  The labels serve both to trigger
advice and to mark continuations that the advice may return to.  These
constructs are defined orthogonally to the other features of the
language and we show that our abstractions can be used in both
functional and object-oriented contexts.  The labels are well-scoped
and the language as a whole is well-typed.  Consequently, programmers
can use lexical scoping in the standard way to prevent aspects from
interfering with local program invariants.
  "
}

@InProceedings{SSDK+03,
  author = 	 {Usa Sammapun and Raman Sharykin and Margaret Delap and Myong Kim and Steve Zdancewic},
  title = 	 {\textbf{Formalizing {Java-MaC}}},
  booktitle =	 {Proceedings of the Third Runtime Verification Workshop},
  publisher =    entcs,
  year =	 2003,
  month =        jul,
  hconf        = "yes",
  plclub        = "yes",
  ps =           "http://www.cis.upenn.edu/~stevez/papers/SSDK03.ps",
  pdf =          "http://www.cis.upenn.edu/~stevez/papers/SSDK03.pdf",
  abstract =     "The Java-MaC framework is a run-time verification system for Java
  programs that can be used to dynamically test and enforce safety
  policies.  This paper presents a formal model of the Java-MaC safety
  properties in terms of an operational semantics for Middleweight
  Java, a realistic subset of full Java.  This model is intended to be
  used as a framework for studying the correctness of Java-MaC program
  instrumentation, optimizations, and future experimentation with
  run-time monitor expressiveness.  As a preliminary demonstration of this model's
  applicability for these tasks, the paper sketches a correctness result
  for a simple program instrumentation scheme.
  "
}


@InProceedings{ZM03,
  author = 	 {Steve Zdancewic and Andrew C. Myers},
  title = 	 {\textbf{Observational Determinism for Concurrent Program Security}},
  booktitle	= "Proc. of 16th IEEE Computer Security Foundations Workshop",
  year =	 2003,
  month =	 jul,
  address =      "Asilomar, CA",
  hconf        = "yes",
  plclub        = "yes",
  ps =           "http://www.cis.upenn.edu/~stevez/papers/ZMO3.ps",
  pdf =          "http://www.cis.upenn.edu/~stevez/papers/ZMO3.pdf",
  abstract =     "Noninterference is a property of sequential programs that is useful
for expressing security policies for data confidentiality and
integrity. However, extending noninterference to concurrent programs has
proved problematic. In this paper we present a relatively expressive
secure concurrent language. This language, based on existing
concurrent calculi, provides first-class channels, higher-order
functions, and an unbounded number of threads.  Well-typed programs
obey a generalization of noninterference that ensures
immunity to internal
timing attacks and to attacks that exploit information about the thread
scheduler. Elimination of these refinement attacks is possible because
the enforced security property extends noninterference with
observational determinism. Although the security property is strong,
it also avoids some of the restrictiveness imposed on 
previous security-typed concurrent languages.
"
}

@InProceedings{GGKS+03,
  author = 	 {Michael Greenwald and Carl A. Gunter and Bj\"{o}rn Knutsson and
                  Andre Scedrov and Jonathan M. Smith and Steve Zdancewic},
  title = 	 {\textbf{Computer Security is Not a Science (but it should be)}},
  booktitle =	 {Proceedings of the Large-Scale Network Security Workshop},
  year =	 2003,
  month =	 mar,
  hconf        = "yes",
  plclub        = "yes",
  ps  =          "GGKS+http://www.cis.upenn.edu/~stevez/papers/03.ps",
  pdf =          "GGKS+http://www.cis.upenn.edu/~stevez/papers/03.pdf"
}

@InProceedings{ZCZM03,
  author = 	 {Lantian Zheng and Stephen Chong and Steve Zdancewic
                  and Andrew C. Myers},
  title = 	 {\textbf{Building Secure Distributed Systems Using Replication and 
                  Partitioning}},
  booktitle =	 {IEEE 2003 Symposium on Security and Privacy},
  year =	 2003,
  publisher =	 ieee,
  hconf        = "yes",
  plclub        = "yes",
  ps        = "http://www.cis.upenn.edu/~stevez/papers/ZCZM03.ps",
  pdf       = "http://www.cis.upenn.edu/~stevez/papers/ZCZM03.pdf",
  
  abstract = "A challenging unsolved security problem is how to
specify and enforce system-wide security policies; this problem is
even more acute in distributed systems with mutual distrust. This
paper describes a way to enforce policies for data confidentiality and
integrity in such an environment. Programs annotated with security
specifications are statically checked and then transformed by the
compiler to run securely on a distributed system with untrusted
hosts. The code and data of the computation are partitioned across the
available hosts in accordance with the security specification.  The
key contribution is automatic replication of code and data to increase
assurance of integrity---without harming confidentiality, and without
placing undue trust in any host.  The compiler automatically generates
secure run-time protocols for communication among the replicated code
partitions. Results are given from a prototype implementation applied
to various distributed programs.  " 
}

@InProceedings{	  ZZNM01,
  year		= 2001,
  author	= "Steve Zdancewic and Lantian Zheng and Nathaniel Nystrom
		  and Andrew C. Myers",
  title		= "\textbf{Untrusted Hosts and Confidentiality: Secure Program Partitioning}",
  series	= "Operating Systems Review",
  booktitle	= sosp18,
  address	= "Banff, Canada",
  month		= oct,
  volume	= "35(5)",
  pages		= {1--14},
  hconf        = "yes",
  plclub        = "yes",
  ps            = "http://www.cis.upenn.edu/~stevez/papers/ZZNM01.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/ZZNM01.pdf",

  abstract = "This paper presents secure program partitioning, a
  language-based technique for protecting confidential data during
  computation in distributed systems containing mutually untrusted
  hosts. Confidentiality and integrity policies can be expressed by
  annotating programs with security types that constrain information
  flow; these programs can then be partitioned automatically to run
  securely on heterogeneously trusted hosts. The resulting
  communicating subprograms collectively implement the original
  program, yet the system as a whole satisfies the security
  requirements of participating principals without requiring a
  universally trusted host machine. The experience in applying this
  methodology and the performance of the resulting distributed code
  suggest that this is a promising way to obtain secure distributed
  computation. "

}


@InProceedings{	  ZM01b,
  author	= "Steve Zdancewic and Andrew C. Myers",
  title		= "\textbf{Robust Declassification}",
  booktitle	= "Proc. of 14th IEEE Computer Security Foundations Workshop",
  month		= jun,
  year		= 2001,
  address	= "Cape Breton, Canada",
  pages		= {15--23},
  hconf        = "yes",
  plclub        = "yes",
  ps            = "http://www.cis.upenn.edu/~stevez/papers/ZM01b.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/ZM01b.pdf",

  abstract = " Security properties based on information flow, such as
  noninterference, provide strong guarantees that confidentiality is
  maintained. However, programs often need to leak some amount of
  confidential information in order to serve their intended purpose,
  and thus violate noninterference. Real systems that control
  information flow often include mechanisms for downgrading or
  declassifying information; however, declassification can easily
  result in the unexpected release of confidential information.


This paper introduces a formal model of information flow in systems
that include intentional information leaks and shows how to
characterize what information leaks. Further, we define a notion of
robustness for systems that include information leaks introduced by
declassification. Robust systems have the property that an attacker is
unable to exploit declassification channels to obtain more
confidential information than was intended to be released. We show
that all systems satisfying a noninterference-like property are
robust; for other systems, robustness involves a nontrivial
interaction between confidentiality and integrity properties. We
expect this model to provide new tools for the characterization of
information flow properties in the presence of intentional information
leaks. " 
}

@InProceedings{	  ZM01,
  author	= {Steve Zdancewic and Andrew C. Myers},
  title		= {\textbf{Secure Information Flow and {CPS}}},
  booktitle	= esop10,
  year		= 2001,
  volume	= 2028,
  month		= apr,
  series	= lncs,
  pages		= {46--61},
  hconf        = "yes",
  plclub        = "yes",
  ps            = "http://www.cis.upenn.edu/~stevez/papers/ZM01.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/ZM01.pdf",

  abstract = "Security-typed languages enforce secrecy or integrity
  policies by type-checking. This paper investigates
  continuation-passing style as a means of proving that such languages
  enforce non-interference and as a first step towards understanding
  their compilation. We present a low-level, secure calculus with
  higher-order, imperative features. Our type system makes novel use
  of ordered linear continuations."

}

@InProceedings{	  ZGM99,
  author	= {Steve Zdancewic and Dan Grossman and Greg Morrisett},
  title		= {\textbf{Principals in Programming Languages: A Syntactic Proof Technique}},
  booktitle	= {Proc. of the 4th ACM SIGPLAN International Conference on
		  Functional Programming},
  year		= 1999,
  pages		= {197--207},
  address	= {Paris, France},
  month		= sep,
  hconf        = "yes",
  plclub        = "yes",
  ps            = "http://www.cis.upenn.edu/~stevez/papers/ZGM99.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/ZGM99.pdf",

  abstract = "Programs are often structured around the idea that
  different pieces of code comprise distinct principals, each with a
  view of its environment. Typical examples include the modules of a
  large program, a host and its clients, or a collection of
  interactive agents.


In this paper, we formalize this notion of principal in the
programming language itself. The result is a language in which
intuitive statements such as, ``the client must call open to obtain a
file handle'', can be phrased and proven formally.


We add principals to variants of the simply-typed lambda-calculus and
show how we can track the code corresponding to each principal
throughout evaluation. This multiagent calculus yields syntactic
proofs of some type abstraction properties that traditionally require
semantic arguments."  
}

@InProceedings{	  MCGG+99,
  author	= "Greg Morrisett and Karl Crary and Neal Glew and Dan
		  Grossman and Richard Samuels and Frederick Smith and David
		  Walker and Stephanie Weirich and Steve Zdancewic",
  title		= "\textbf{{TALx86}: A Realistic Typed Assembly Language}",
  booktitle	= "2nd {ACM SIGPLAN} Workshop on Compiler Support for
		  System Software",
  year		= 1999,
  pages		= {25--35},
  hconf        = "yes",
  plclub        = "yes",
  ps            = "MCGG+http://www.cis.upenn.edu/~stevez/papers/99.ps",
  pdf           = "MCGG+http://www.cis.upenn.edu/~stevez/papers/99.pdf",

  abstract = "The goal of typed assembly language (TAL) is to provide
  a low-level, statically typed target language that is better suited
  than Java bytecodes for supporting a wide variety of source
  languages and a number of important optimizations. In previous work,
  we formalized idealized versions of TAL and proved important safety
  properties about them. In this paper, we present our progress in
  defining and implementing a realistic typed assembly language called
  TALx86. The TALx86 instructions comprise a relatively complete
  fragment of the Intel IA32 (32-bit 80x86 flat model) assembly
  language and are thus executable on processors such as the Intel
  Pentium. The type system for the language incorporates a number of
  advanced features necessary for safely compiling large programs to
  good code.


To motivate the design of the type system, we demonstrate how various
high-level language features are compiled to TALx86. For this purpose,
we present a type-safe C-like language called Popcorn."  
}


@TechReport{TZ05atr,
  author = 	 {Stephen Tse and Steve Zdancewic},
  title = 	 {\textbf{Designing a Security-typed Language with Certificate-based Declassification}},
  institution =  {University of Pennsylvania},
  number =       "MIS-CIS-04-16",
  year = 	 2004,
  htr =          "yes",
  plclub        = "yes",
  pdf   =        "http://www.cis.upenn.edu/~stevez/papers/TZ05atr.pdf",
  abstract = 
  "This paper presents the design of a programming language that
  supports information-flow security policies and certificate-based
  declassification.

  
  The language uses monadic information-flow annotations in the style
  of Abadi et al.'s dependency core calculus, and has an effects
  system and fixpoints. The type system conflates security concepts
  such as labels, principals, and privileges with abstract types,
  allowing a uniform treatment of lattice structures throughout the
  language.  Myers' and Liskov's decentralized label model is encoded
  using type constructors that describe confidentiality and integrity
  policies, and label refinements and principal groups follow
  naturally from intersection and union types.  Singleton types,
  combined with bounded universal and existential quantifications,
  connect the type system with public-key infrastructures whose
  digital certificates provide authorization for privileged operations
  such as declassification.  These features allow specification of
  security policies in term of dynamic entities such as run-time user
  identities and file access permissions.

  
  Besides showing that the language is sound, we present a security
  theorem that generalizes standard noninterference to account for
  information flows introduced by declassification.  Although this
  result gives only a coarse approximation to the information
  potentially leaked, it captures our intuitions about
  certificate-based declassification.
  "
}



@TechReport{TZ04c,
  author = 	 {Stephen Tse and Steve Zdancewic},
  title = 	 {\textbf{Translating Dependency into Parametricity}},
  institution =  {University of Pennsylvania},
  year = 	 2004,
  number =	 "MIS-CIS-04-01",
  htr      =     "yes",
  plclub        = "yes",
  pdf      =     "http://www.cis.upenn.edu/~stevez/papers/TZ04btr.pdf",
  abstract =     "
  The \textit{dependency core calculus} (DCC) was introduced by Abadi
  et al. as a unifying formal framework in which to study a variety of
  important program analyses including binding-time, information-flow,
  slicing, and function call tracking. The novel feature of DCC is a
  lattice of monads and a nonstandard typing rule for their associated
  \texttt{bind} operations.  Intuitively, the lattice structure describes
  which computations in a program may depend on each other.  Abadi et
  al.  prove a \textit{noninterference} result that establishes the
  correctness of DCC's type system, and they use that result to show
  that type systems for the above-mentioned analyses are correct.
  
  In this paper, we study the relationship between DCC and the
  Girard--Reynolds polymorphic lambda calculus (System F).  In
  particular, we show how to encode the recursion-free fragment of DCC
  into F via a type-directed translation.  The main theorem we present
  uses this translation to derive the noninterference result for DCC
  from the standard parametricity theorem of System F.  In addition to
  providing insight into DCC's type system, the hope is that the
  translation presented here may yield implementation strategies for
  non-standard type systems (e.g. for information flow security) in
  languages that have parametric polymorphism.
  "
}

@TechReport{TZ03,
  author = 	 {Stephen Tse and Steve Zdancewic},
  title = 	 {\textbf{Run-time Principals in Information-flow Type Systems}},
  institution =  {University of Pennsylvania},
  year = 	 2003,
  number =	 "MS-CIS-03-39",
  note  =        {The conference version appears in {IEEE} Security and Privacy 2004},
  htr      =     "yes",
  plclub        = "yes",
  ps           = "http://www.cis.upenn.edu/~stevez/papers/TZ03.ps",
  pdf          = "http://www.cis.upenn.edu/~stevez/papers/TZ03.pdf",
  abstract =     "
  Information-flow type systems are a promising approach for enforcing
  strong end-to-end confidentiality and integrity policies. Such
  policies, however, are usually specified in term of static
  information--data is labeled \textit{high} or \textit{low} security at
  compile time.  In practice, the confidentiality of data may depend
  on information available only while the system is running

  
  This paper studies language support for \textit{run-time principals}, a
  mechanism for specifying information-flow security policies that
  depend on which principals interact with the system.  We establish
  the basic property of noninterference for programs written in such
  language, and use run-time principals for specifying run-time
  authority in downgrading mechanisms such as declassification.

  
  In addition to allowing more expressive security policies, run-time
  principals enable the integration of language-based security
  mechanisms with other existing approaches such as Java stack
  inspection and public key infrastructures. We sketch an
  implementation of run-time principals via public keys such that
  principal delegation is verified by certificate chains.
  "
}

@PhdThesis{Zda02,
  author = 	 {Stephan A. Zdancewic},
  title = 	 {\textbf{Programming Languages for Information Security}},
  school = 	 {Cornell University},
  year = 	 2002,
  month =	 aug,
  ps            = "http://www.cis.upenn.edu/~stevez/papers/Zda02.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/Zda02.pdf",
  abstract      = "Our society's widespread dependence on networked information systems
for everything from personal finance to military communications makes
it essential to improve the security of software.  Standard security
mechanisms such as access control and encryption are essential
components for protecting information, but they do not provide
end-to-end guarantees.  Programming-languages research has
demonstrated that security concerns can be addressed by using both
program analysis and program rewriting as powerful and flexible
enforcement mechanisms.


This thesis investigates  \emph{security-typed
programming languages}, which use static typing to enforce
information-flow security policies.  These languages allow the
programmer to specify confidentiality and integrity constraints on the
data used in a program; the compiler verifies that the
program satisfies the constraints.


Previous theoretical security-typed languages research has focused on
simple models of computation and unrealistically idealized security
policies.  The existing practical security-typed languages have not
been proved to guarantee security.  This thesis addresses these
limitations in several ways.


First, it establishes \emph{noninterference}, a basic information-flow
policy, for languages richer than those previously considered.  The
languages studied here include recursive, higher-order functions,
structured state, and concurrency.  These results narrow the gap
between the theory and the practice of security-typed languages.


Next, this thesis considers more practical security policies.
Noninterference is often too restrictive for real-world programming.
To compensate, a restricted form of declassification is introduced,
allowing programmers to specify a richer set of information-flow
policies.  Previous work on information-flow security also assumed
that all computation occurs on equally trusted machines.  To overcome
this unrealistic premise, additional security constraints for systems
distributed among heterogeneously trusted hosts are considered.


Finally, this thesis describes Jif/split, a prototype implementation
of \emph{secure program partitioning}, in which a program can automatically
be partitioned to run securely on heterogeneously trusted hosts. The
resulting communicating subprograms collectively implement the
original program, yet the system as a whole satisfies the security
requirements without needing a universally trusted machine.  The
theoretical results developed earlier in the thesis justify
Jif/split's run-time enforcement mechanisms."
}

@TechReport{	  ZZNM01b,
  year		= 2001,
  title		= "\textbf{Secure Program Partitioning}",
  author	= "Steve Zdancewic and Lantian Zheng and Nathaniel Nystrom
		  and Andrew C. Myers",
  institution	= "Computer Science Dept., Cornell University",
  number	= "2001-1846",
  htr      =     "yes",
  plclub        = "yes",
  ps            = "http://www.cis.upenn.edu/~stevez/papers/ZZNM01b.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/ZZNM01b.pdf",

  abstract = "This paper presents secure program partitioning, a
  language-based technique for protecting confidential data during
  computation in distributed systems containing mutually untrusted
  hosts. Confidentiality and integrity policies can be expressed by
  annotating programs with security types that constrain information
  flow; these programs can then be partitioned automatically to run
  securely on heterogeneously trusted hosts. The resulting
  communicating subprograms collectively implement the original
  program, yet the system as a whole satisfies the security
  requirements of participating principals without requiring a
  universally trusted host machine. The experience in applying this
  methodology and the performance of the resulting distributed code
  suggest that this is a promising way to obtain secure distributed
  computation.


This Technical Report is an expanded version of the published paper
``Untrusted Hosts and Confidentiality: Secure Program Partitioning''.
The main difference between the two is Appendix A, which contains a
correctness proof for the control-transfer protocols described in
Section 5."  
}


@TechReport{	  ZM00,
  author	= {Steve Zdancewic and Andrew C. Myers},
  title		= {\textbf{Confidentiality and Integrity with Untrusted Hosts}},
  institution	= {Computer Science Dept., Cornell University},
  year		= 2000,
  number	= {2000-1810},
  htr      =     "yes",
  plclub        = "yes",
  ps            = "http://www.cis.upenn.edu/~stevez/papers/ZM00.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/ZM00.pdf",
  abstract      = "Several \emph{security-typed languages} have recently been proposed to enforce
security properties such as confidentiality or integrity by type checking.
We propose a new security-typed language, Spl@, that
addresses two important limitations of previous approaches.


First, existing languages assume that the underlying execution platform
is trusted; this assumption does not scale to distributed computation in
which a variety of differently trusted hosts are available to execute
programs. Our new approach, \emph{secure program partitioning}, translates
programs written assuming complete trust in a single executing host into
programs that execute using a collection of variously trusted hosts to
perform computation.  As the trust configuration of a distributed system
evolves, this translation can be performed as necessary for security.


Second, many common program transformations do not work in existing
security-typed languages; although they produce equivalent
programs, these programs are rejected because of \emph{apparent} information
flows. Spl@ uses a novel mechanism
based on \emph{ordered linear continuations} to permit a richer class of program
transformations, including secure program partitioning."

}

@TechReport{	  ZG99,
  author	= {Steve Zdancewic and Dan Grossman},
  title		= {\textbf{Principals in Programming Languages: Technical Results}},
  institution	= {Computer Science Dept., Cornell University},
  year		= 1999,
  number	= {TR99-1752},
  month		= jun,
  htr      =     "yes",
  plclub        = "yes",
  ps            = "http://www.cis.upenn.edu/~stevez/papers/ZG99.ps",
  pdf           = "http://www.cis.upenn.edu/~stevez/papers/ZG99.pdf",

  abstract = "This is the companion technical report for ``Principals
  in Programming Languages: A Syntactic Proof Technique.'' See that
  document for a more readable version of these results.


In this paper, we describe two variants of the simply typed
lambda-calculus extended with a notion of principal. The results are
languages in which intuitive statements like ``the client must call
open to obtain a file handle'' can be phrased and proven formally.


The first language is a two-agent calculus with references and
recursive types, while the second language explores the possibility of
multiple agents with varying amounts of type information. We use these
calculi to give syntactic proofs of some type abstraction results that
traditionally require semantic arguments. " 
}

